File: .gpteditignore --- venv/**/* examples/**/* .idea/**/* **/pycache/**/* ---Directory: .well-knownFile: ai-plugin.json --- { "schema_version": "v1", "name_for_human": "File Editor (no auth)", "name_for_model": "file_editor", "description_for_human": "Plugin for reading and editing files for projects.", "description_for_model": "Plugin for reading and editing files for projects. It can list, read, write and delete files for a specific project.", "auth": { "type": "none" }, "api": { "type": "openapi", "url": "http://localhost:5003/openapi.yaml" }, "logo_url": "http://localhost:5003/logo.png", "contact_email": "legal@example.com", "legal_info_url": "http://example.com/legal" }  ---File: README.md --- # ChatGPT File Editor This plugin allows you to create and edit files in a directory on your computer using ChatGPT. _(If you do not already have plugin developer access, please [join the waitlist](https://openai.com/waitlist/plugins).)_ The advantage of this plugin compared to similar offerings is that it is completely local. Your project files don't need to be on a publicly available repository (as long as you trust OpenAI's privacy policy). You also don't have to push your changes everytime you make a change. ⚠️ I would still recommend using a version control system like Git to keep track of your changes and to be able to revert them if needed. ## Setup locally To install the required packages for this plugin, run the following command: ```bash pip install -r requirements.txt ``` To run the plugin, enter the following command: ```bash python main.py ``` Once the local server is running: 1. Navigate to https://chat.openai.com. 2. In the Model drop down, select "Plugins" (note, if you don't see it there, you don't have access yet). 3. Select "Plugin store" 4. Select "Develop your own plugin" 5. Enter in `localhost:5003` since this is the URL the server is running on locally, then select "Find manifest file". The plugin should now be installed and enabled! You can start with a question like "What files are in the project ?" ## Managing projects ### Manually adding projects The directories accessible by ChatGPT File Editor are stored in the [projects.yaml](projects.yaml) file. To add a new project, add a new entry to the `projects` list. - The `full_name` field is the name of the project that will be displayed in the File Editor. - The `path` field is the path to the directory that contains the files for the project. - The `slug` field is the name of the project that will be used in the URL for the File Editor. ### Using the dashboard Projects can also be edited using the dashboard available at http://localhost:5003/dashboard. Renaming and deleting does not affect the files on disk, only the `projects.yaml` file. ### Excluding files Files can be excluded from the File Editor by adding a `.gpteditignore` file to the project directory. The format of the `.gpteditignore` file is the same as the `.gitignore` file. ## Q & A ### How does this defer from GitHub Copilot ? Copilot allows you to edit files on the fly, but it does not allow you to create new files or to list the files in a directory. This plugin is able to know which files to edit based on your request. ### Is this only for code projects ? No, this plugin can be used for any type of project. I personally use it for slideshow presentations made with Beamer or Reveal.js. ### How do I add a new file ? You can add a new file by asking a question like "Create a new file called `file_name`". ### How do I edit a file ? You can edit a file by asking a question like "Edit `file_name`". ### How do I list all the files in the project ? You can list all the files in the project by asking a question like "What files are in the project ?". ### How do I list all the files in a directory ? You can list all the files in a directory by asking a question like "What files are in the `directory_name` directory ?". ### How do I delete a file ? You can't delete files. This is to prevent accidental deletion of files. Maybe this will be added as an opt-in feature in the future.  ---Directory: SingletonFile: __init__.py --- class Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs) return cls._instances[cls]  ---File: logo.png (media file, content not displayed)File: main.py --- import os import sys import quart import quart_cors from routes import projects_routes, api_routes, dashboard_routes os.system('') # Needed to enable VT100 support sys.stdout.write("\x1b[8;{rows};{cols}t".format(rows=32, cols=999)) app = quart_cors.cors(quart.Quart(__name__), allow_origin="https://chat.openai.com") # set env to development app.config["ENV"] = "development" # Register routes app.register_blueprint(projects_routes) app.register_blueprint(api_routes) app.register_blueprint(dashboard_routes) def main(): """ Main function to start the application. The application will be run in debug mode and will listen on all interfaces at port 5003. """ app.run(debug=True, host="0.0.0.0", port=5003) if __name__ == "__main__": main()  ---File: openapi.yaml --- openapi: 3.0.1 info: title: File Editor Plugin description: | A plugin that allows the user to read and edit files for projects. It can list, read, write and delete files for a specific project. Edits are made by replacing the contents of the file. File lines shouldn't be shown unless explicitly requested. Multiple files can be interacted with, individually. If a file is edited, it should be reloaded to check the edits and apply corrections if needed. The file contents should be shown in a text editor. If you do not know the name of the project, ask the user to select it from a list. version: 'v2' servers: - url: http://localhost:5003 paths: /projects/{project}/files: get: operationId: getFiles summary: Get the list of files, url encoded. parameters: - in: path name: project schema: type: string required: true description: The name of the project. - in: query name: path schema: type: string required: false description: The path to the directory to list. - in: query name: recursive schema: type: boolean required: false description: Whether to list files recursively. - in: query name: query schema: type: string required: false description: The query to search for, as a glob pattern. responses: "200": description: OK content: application/json: schema: $ref: '#/components/schemas/getFilesResponse' /projects/{project}/file: get: operationId: getFile summary: Get information about a file and its contents parameters: - in: path name: project schema: type: string required: true description: The name of the project. - in: query name: filename schema: type: string required: true description: The name of the file. responses: "200": description: OK content: application/json: schema: $ref: '#/components/schemas/getFileResponse' post: operationId: setFileContents summary: Set the contents of a file parameters: - in: path name: project schema: type: string required: true description: The name of the project. - in: query name: filename schema: type: string required: true description: The name of the file. requestBody: required: true content: application/json: schema: $ref: '#/components/schemas/setFileContentsRequest' responses: "200": description: OK put: operationId: editFile summary: Edit a file parameters: - in: path name: project schema: type: string required: true description: The name of the project. - in: query name: filename schema: type: string required: true description: The name of the file. requestBody: required: true content: application/json: schema: $ref: '#/components/schemas/editFileRequest' responses: "200": description: OK components: schemas: getFilesResponse: type: object properties: files: type: array items: type: string description: The list of files. getFileResponse: type: object properties: full_path: type: string description: The full path of the file. last_modified: type: string description: The last modified date of the file. created: type: string description: The creation date of the file. contents: type: array description: | 'The contents of the file, each line is prepended with a line number in the format of "line_number: line_content".' The line numbers should be shown only if explicitly requested. items: type: string editFileRequest: type: object required: - first_line - last_line - content properties: first_line: type: integer description: The first line of the replaced block in the original file. last_line: type: integer description: The last line of the replaced block in the original file. content: type: array description: The content to replace the lines with. items: type: string setFileContentsRequest: type: object required: - contents properties: contents: type: array description: The contents of the file. items: type: string  ---Directory: projectFile: __init__.py --- from .project import projects, Project  ---File: project.py --- from pathlib import Path import yaml from Singleton import Singleton PROJECTS_YAML = 'projects.yaml' class Project: """ A class representing a project. Attributes: full_name (str): The full name of the project. slug (str): The slug of the project. path (Path): The path of the project. file_cache (list[str]): A list of files in the project. """ file_cache: list[str] def __init__(self, full_name, slug, path): """ Initialize a Project instance. Args: full_name (str): The full name of the project. slug (str): The slug of the project. path (str): The path of the project. """ self.full_name = full_name self.slug = slug self.path = Path(path).absolute() self.file_cache = [] def to_dict(self): return { 'full_name': self.full_name, 'slug': self.slug, 'path': str(self.path), } class Projects(metaclass=Singleton): """ Projects Singleton Stores the projects in a dictionary Can load / save projects to a yaml file """ projects = {} def __init__(self): self._load_projects() def _load_projects(self): # Create projects.yaml if it doesn't exist if not Path(PROJECTS_YAML).exists(): with open(PROJECTS_YAML, 'w') as f: yaml.dump({}, f) with open(PROJECTS_YAML, 'r') as f: pj = yaml.load(f, Loader=yaml.FullLoader) self.projects = {slug: Project(**project) for slug, project in pj.items()} def _save_projects(self): with open(PROJECTS_YAML, 'w') as f: yaml.dump({slug: project.to_dict() for slug, project in self.projects.items()}, f) def add(self, slug, project): self.projects[slug] = project self._save_projects() def delete(self, slug): del self.projects[slug] self._save_projects() def get_all(self): return self.projects def get(self, slug): return self.projects[slug] def __getitem__(self, slug): return self.projects[slug] def __setitem__(self, key, value): self.projects[key] = value self._save_projects() def __delitem__(self, key): del self.projects[key] self._save_projects() def __contains__(self, slug): return slug in self.projects projects = Projects()  ---File: projects.yaml --- example-project: full_name: Example Project path: /home/username/projects/example-project slug: example-project ---File: requirements.txt --- quart~=0.18.4 quart-cors requests~=2.31.0 beautifulsoup4~=4.12.2 html2text~=2020.1.16 readability~=0.3.1 PyYAML~=6.0 gitignore_parser~=0.1.3 pathspec~=0.11.1 ---Directory: routesFile: __init__.py --- from .projects import projects_routes from .api import api_routes from .dashboard import dashboard_routes  ---File: api.py --- import quart from quart import Blueprint, request api_routes = Blueprint('api', __name__) @api_routes.get("/logo.png") async def plugin_logo(): filename = 'logo.png' return await quart.send_file(filename, mimetype='image/png') @api_routes.get("/.well-known/ai-plugin.json") async def plugin_manifest(): host = request.headers['Host'] with open("./.well-known/ai-plugin.json") as f: text = f.read() response = quart.Response(text, mimetype="text/json") response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate" # Or any other directive you need return response @api_routes.get("/openapi.yaml") async def openapi_spec(): host = request.headers['Host'] with open("openapi.yaml") as f: text = f.read() return quart.Response(text, mimetype="text/yaml") @api_routes.route("/<path:path>", methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"]) async def catch_all(path): print(f"Path: /{path}") print(f"Request: {request}") print(f"Request headers: {request.headers}") print(f"Request query args: {request.args}") print(f"Request body: {await request.get_data()}") return quart.Response(response="OK", status=200)  ---File: dashboard.py --- import quart from quart import Blueprint, render_template, request from project.project import projects, Project dashboard_routes = Blueprint('dashboard_routes', __name__) @dashboard_routes.get('/dashboard') async def dashboard(): print(projects.get_all()) return await render_template('dashboard.html', projects=projects.get_all()) @dashboard_routes.post('/dashboard/project') async def create_project(): form = await request.form if form['slug'] in projects: return quart.redirect('/dashboard') full_name = form.get('full_name') slug = form.get('slug') path = form.get('path') # Add your logic for creating a new project here projects[slug] = Project(full_name, slug, path) return quart.redirect('/dashboard') @dashboard_routes.put('/dashboard/project/<slug>') async def update_project(slug): # body is json body = await request.get_json(force=True) # Find the project with the given slug project = projects[slug] # Update the project's full_name and path and slug project.full_name = body['full_name'] project.path = body['path'] project.slug = body['slug'] return quart.redirect('/dashboard') @dashboard_routes.delete('/dashboard/project/<slug>') async def delete_project(slug): # Add your logic for deleting a project here del projects[slug] return '', 204 @dashboard_routes.route('/favicon.ico') async def favicon(): return await quart.send_file('logo.png', mimetype='image/vnd.microsoft.icon')  ---File: projects.py --- import json import quart from quart import Blueprint from project import projects from utils import file_search projects_routes = Blueprint('projects', __name__) @projects_routes.get("/projects/<string:project_name>/files") async def get_files(project_name): """ Get the list of files in a project. Args: project_name (str): The name of the project. Returns: quart.Response: A response object with the list of files. """ print(f'Querying files for project "{project_name}"') try: project = projects[project_name] except KeyError: return quart.Response(response=json.dumps({ "error": f"Project {project_name} not found", }), status=404) project.file_cache = file_search(project, '*') print(project.file_cache[:20]) print(len(project.file_cache)) return quart.Response(response=json.dumps(project.file_cache), status=200) @projects_routes.get("/projects/<string:project>/file") async def get_file(project): """ Get the contents of a file in a project. Args: project (str): The name of the project. Returns: quart.Response: A response object with the file contents. """ filename = quart.request.args.get("filename") print(f'Querying file "{filename}" for project "{project}"') if project not in projects.get_all(): return quart.Response(response=json.dumps({ "error": f"Project {project} not found", }), status=404) file = projects[project].path / filename if not file.exists(): return quart.Response(response=json.dumps({ "error": f"File {filename} not found", }), status=404) contents = file.read_text().splitlines() # Add a line number to each line contents = [f"{i + 1}: {line}" for i, line in enumerate(contents)] return quart.Response(response=json.dumps({ "full_path": str(file.absolute()), "last_modified": file.stat().st_mtime, "created": file.stat().st_ctime, "contents": contents, }), status=200) @projects_routes.post("/projects/<string:project>/file") async def set_file_contents(project): """ Set the contents of a file in a project. Args: project (str): The name of the project. Returns: quart.Response: A response object indicating the success of the operation. """ data = await quart.request.get_json(force=True) print(data) filename = quart.request.args.get("filename") print(f'Setting file "{filename}" for project "{project}"') file = projects[project].path / filename print(data) contents = '\n'.join(data["contents"]) file.parent.mkdir(parents=True, exist_ok=True) file.write_text(contents) return quart.Response(response='OK', status=200) @projects_routes.put("/projects/<string:project>/file") async def edit_file(project): """ Edit specific lines in a file in a project. Args: project (str): The name of the project. Returns: quart.Response: A response object indicating the success of the operation. """ data = await quart.request.get_json(force=True) filename = quart.request.args.get("filename") print(f'Editing file "{filename}" for project "{project}"') file_path = projects[project].path / filename first_line = data["first_line"] last_line = data["last_line"] content = data["content"] # append newlines to the content content = [f"{line}\n" for line in content] print(f'Editing lines {first_line} to {last_line} with:\n\n"{content}"') with file_path.open() as f: lines = f.readlines() # Replace the specified lines with the new content lines[first_line - 1:last_line] = content with file_path.open('w') as f: f.writelines(lines) return quart.Response(response='OK', status=200)  ---Directory: templatesFile: dashboard.html --- <!DOCTYPE html> <html> <head> <title>Dashboard</title> <style> /* Draw lines between table columns */ table { border-collapse: collapse; } td { border-left: 1px solid black; border-right: 1px solid black; padding: 5px; /* no wrap */ white-space: nowrap; } table, th { border: 1px solid black; } /* Alternate row colors */ tr:nth-child(even) { background-color: #dddddd; } th { background-color: #cccccc; } </style> </head> <body> <h1>Welcome to the Dashboard!</h1> <table> <thead> <tr> <th>Full Name</th> <th>Slug</th> <th>Path</th> <th>Action</th> </tr> </thead> <tbody> {% for project in projects.values() %} <tr> <td>{{ project.full_name }}</td> <td>{{ project.slug }}</td> <td>{{ project.path }}</td> <td> <button onclick="deleteProject('{{ project.slug }}')">🗑️</button> <button onclick="editProjectForm('{{ project.slug }}')">✏️</button> </td> </tr> {% endfor %} </tbody> </table> <br> <form action="/dashboard/project" method="post" name="create_project"> <input type="hidden" name="original_slug"> <label for="full_name">Full Name:</label><br> <input type="text" id="full_name" name="full_name"><br> <label for="slug">Slug:</label><br> <input type="text" id="slug" name="slug"><br> <label for="path">Path:</label><br> <input type="text" id="path" name="path"><br> <div style="height: 10px;"></div> <input type="submit" value="Create Project"> <button id="edit" onclick="editProject()" style="display: none;">Edit</button> <button type="reset">Clear</button> </form> <script> const form = document.forms['create_project']; form.onreset = () => { document.querySelector('input[type="submit"]').style.display = 'inline-block'; document.querySelector('button#edit').style.display = 'none'; }; function deleteProject(slug) { if (confirm('Are you sure you want to delete this project?')) { fetch('/dashboard/project/' + slug, { method: 'DELETE', }).then(() => location.reload()); } } function editProjectForm(slug) { console.log('editProjectForm', slug); // hide the create button and show the edit button document.querySelector('input[type="submit"]').style.display = 'none'; document.querySelector('button#edit').style.display = 'inline-block'; // set the original slug in the form form['original_slug'].value = slug; // fill the form with the project data from the table const project = Array.from(document.querySelectorAll('tr')).find(tr => tr.children[1].textContent === slug); form['full_name'].value = project.children[0].textContent; form['slug'].value = project.children[1].textContent; form['path'].value = project.children[2].textContent; } function editProject() { const originalSlug = form['original_slug'].value; const fullName = form['full_name'].value; const slug = form['slug'].value; const path = form['path'].value; fetch('/dashboard/project/' + originalSlug, { method: 'PUT', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ full_name: fullName, slug: slug, path: path, }), }).then(() => location.reload()); } </script> </body> </html> ---Directory: utilsFile: __init__.py --- # from .Singleton import Singleton import urllib.parse import pathspec from project import Project def path_to_url(path): return urllib.parse.quote(path).replace('/', '%2F') def url_to_path(url): return urllib.parse.unquote(url).replace('%2F', '/') def file_search(project: Project, search_pattern): # Get all files in directory recursively all_files = project.path.rglob(search_pattern) # Load .gitignore-like file ignore_path = project.path / '.gpteditignore' print(f'ignore_path: {ignore_path}') if ignore_path.exists(): spec = pathspec.GitIgnoreSpec.from_lines(ignore_path.read_text().splitlines()) return [(str(f.relative_to(project.path))) for f in all_files if not spec.match_file(str(f.relative_to(project.path))) and not f.name.endswith('.gpteditignore')] else: # Use generator expression instead of list comprehension return (str(f.relative_to(project.path)) for f in all_files)  ---