File: constants.js --- const appRoot = require('app-root-path');require('dotenv').config({ path: `${appRoot}/.env` });const USE_TEST_QUIZ = false// process.env.NODE_ENV == 'development' ? true :  false;const QUESTION_TIMER_DURATION = 15;const CORRECT_ANSWER_XP = 10;const DELAY_BEFORE_NEXT_QUESTION =3000 // 3000; // 3 secondsconst TEST_QUIZ = {    questions: [        { question: "Example Question 1", answers: ["Answer 1", "Answer 2", "Answer 3", "Answer 4"] },        { question: "Example Question 2", answers: ["Answer 1", "Answer 2", "Answer 3", "Answer 4"] },        { question: "Example Question 3", answers: ["Answer 1", "Answer 2", "Answer 3", "Answer 4"] },        { question: "Example Question 4", answers: ["Answer 1", "Answer 2", "Answer 3", "Answer 4"] },    ],    correctAnswers: {        0: [0],        1: [0],        2: [0],        3: [0],    }};const ROOM_CODE_WORDS = ['Cat','Dog','Mom','Dad','Hat','Car','Bed','Red','Box','Bat','Mat','Pig','Hen','Leg','Arm','Sky','Ice','Ant','Fox','Bag','Pen','Map','Jam','Zip','Pot','Pan','Net','Fog','Rat','Sit','Top','Big','Sad','Hot','Wet','Dry','New','Old','Up','Log','Lip','Rib','Hip','Lid','Web','Wig','Jet','Van','Fin','Dip','Bat','Nap','Yap','Kid','Win','Fix','Wax','Mix','Yes','Sky','Dew','Fog','Elk','Ash','Elm','Fig','Fly','Ant', 'baka', 'goku', 'doki', 'nani', 'gojo', 'jogo', 'gai', 'kaka', 'messi','cr', 'bro', 'lol', 'sousou', 'mimi', 'woh', 'zoro', 'nami', 'robin', 'roger', 'ace' ,'shanks', 'minato', 'haki', 'doudi', 'karem', 'hama', 'yezzi', 'yeet', 'mario','joyboy'];module.exports = { USE_TEST_QUIZ, QUESTION_TIMER_DURATION, CORRECT_ANSWER_XP, DELAY_BEFORE_NEXT_QUESTION, ROOM_CODE_WORDS, TEST_QUIZ }; ---Directory: dbFile: db.js --- const knex = require('knex');const config = require('./knexfile.js');const env = process.env.NODE_ENV || 'development';const connection = knex(config[env]);module.exports = connection; ---File: knexfile.js --- /** * @type { Object.<string, import("knex").Knex.Config> } *///to create a new migration file, use this command: npx knex --knexfile ./db/knexfile.js  migrate:make migration_namemodule.exports = {    development: {      client: 'pg',      connection: {        host: 'localhost',        user: 'postgres',        password: 'admin',        database: 'class-clash-local',        port: 5432      },      migrations: {        tableName: 'knex_migrations',        directory: './migrations'      }    },    test: {      client: 'pg',      connection: {        host: 'localhost',        user: 'postgres',        password: 'admin',        database: 'class-clash-local',        port: 5432      },      migrations: {        tableName: 'knex_migrations',        directory: './migrations'      }    },    production: {      client: 'pg',      connection: {        host: process.env.DB_HOST,        user: process.env.DB_USER,        password: process.env.DB_PASSWORD,        database: process.env.DB_DATABASE,        port: process.env.DB_PORT      },      migrations: {        tableName: 'knex_migrations',        directory: './migrations'      }    }  }; ---Directory: migrationsFile: 20240222020025_create_player_table.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.createTable('player', function(table) {      table.increments('player_id').primary(); // Primary key that auto increments      table.string('player_uid').notNullable(); // UUID from Firebase Auth      table.string('player_email').notNullable().unique(); // Player's email, ensuring uniqueness      table.timestamp('player_created_on').defaultTo(knex.fn.now()); // Timestamp of when the player was created      table.string('player_first_name').notNullable(); // Player's first name      table.string('player_last_name').notNullable(); // Player's last name        // Any additional columns you find necessary can be added here      // For example, a column for storing hashed passwords (if authentication is handled separately from Firebase)      // table.string('player_password_hash');    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.dropTable('player');  };   ---File: 20240222235427_add_picture_and_xp_columns_to_player.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.table('player', function(table) {        table.bigInteger('player_xp').defaultTo(0); // Adds a bigInteger column for player_xp with a default value of 0        table.string('player_profile_picture_url', 2048); // Adds a string column for player_profile_picture_url, specifying a max length (2048 characters should be enough for a URL)    });};/** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.down = function(knex) {    return knex.schema.table('player', function(table) {        table.dropColumn('player_xp'); // Removes the player_xp column        table.dropColumn('player_profile_picture_url'); // Removes the player_profile_picture_url column    });}; ---File: 20240223193227_add_country_to_player.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.table('player', function(table) {      table.string('player_country').nullable(); // Using nullable() if the column can be empty    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.table('player', function(table) {      table.dropColumn('player_country'); // Removing the column in the rollback    });  };   ---File: 20240224220047_update_player_xp_to_player_total_xp.js --- /** * When running the migration, this function will be called * It renames the column 'player_xp' to 'player_total_xp' in the 'player' table * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.table('player', function(table) {      table.renameColumn('player_xp', 'player_total_xp');    });  };    /**   * When rolling back the migration, this function will be called   * It renames the column 'player_total_xp' back to 'player_xp' in the 'player' table   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.table('player', function(table) {      table.renameColumn('player_total_xp', 'player_xp');    });  };   ---File: 20240226052823_add_grade_table.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.createTable('grade', function(table) {      table.increments('grade_id').primary(); // Auto-incrementing primary key      table.string('grade_key_name', 255).notNullable().unique(); // Unique key name for internal use      table.string('grade_display_name', 255).notNullable(); // User-friendly display name    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.dropTable('grade'); // Drops the 'grade' table  };   ---File: 20240226054926_add_subject_table.js --- // Migration script for creating the 'subject' table with consistent naming conventions/** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.createTable('subject', function(table) {      table.increments('subject_id').primary(); // Auto-incrementing primary key      table.integer('grade_id').unsigned().notNullable(); // Foreign key to 'grade' table      table.string('subject_key_name', 255).notNullable().unique(); // Unique key name for internal use      table.string('subject_display_name', 255).notNullable(); // User-friendly display name            // Foreign key constraint      table.foreign('grade_id').references('grade_id').inTable('grade');    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.dropTable('subject'); // Drops the 'subject' tabl  };   ---File: 20240226055227_add_lesson_table.js --- // Migration script for creating the 'lesson' table with consistent naming conventions/** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.createTable('lesson', function(table) {      table.increments('lesson_id').primary(); // Auto-incrementing primary key      table.integer('subject_id').unsigned().notNullable(); // Foreign key to 'subject' table      table.string('lesson_key_name', 255).notNullable().unique(); // Unique key name for internal use      table.string('lesson_display_name', 255).notNullable(); // User-friendly display name      table.text('lesson_content').notNullable(); // Large text field for the lesson content        // Foreign key constraint      table.foreign('subject_id').references('subject_id').inTable('subject');    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.dropTable('lesson'); // Drops the 'lesson' tabl  };   ---File: 20240227052159_add_subject_display_image_column.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.table('subject', function(table) {      table.string('subject_display_image', 500); // Adjust the column type as needed, string is used here for example    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.table('subject', function(table) {      table.dropColumn('subject_display_image');    });  };   ---File: 20240227054305_add_lesson_display_image_column.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.table('lesson', function(table) {      table.string('lesson_display_image', 500); // Adjust the column type as needed, string is used here for example    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.table('lesson', function(table) {      table.dropColumn('lesson_display_image');    });  };   ---File: 20240227223107_add_grade_id_to_player_table.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.table('player', function(table) {      table.integer('grade_id').unsigned().nullable(); // Make grade_id nullable      table.foreign('grade_id').references('grade.grade_id'); // Add foreign key constraint    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.table('player', function(table) {      table.dropForeign('grade_id'); // Drop foreign key constraint first      table.dropColumn('grade_id'); // Then drop the column    });  };   ---File: 20240311214721_add_player_admin_to_player_table.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.table('player', function(table) {      table.boolean('player_admin').defaultTo(false);    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.table('player', function(table) {      table.dropColumn('player_admin');    });  };   ---File: 20240312003414_remove_key_name_columns.js --- /** * @param { import("knex").Knex } knex */exports.up = function(knex) {  return knex.schema    .table('grade', function(table) {      table.dropColumn('grade_key_name');    })    .table('subject', function(table) {      table.dropColumn('subject_key_name');    })    .table('lesson', function(table) {      table.dropColumn('lesson_key_name');    });};/** * @param { import("knex").Knex } knex */exports.down = function(knex) {  return knex.schema    .table('grade', function(table) {      table.string('grade_key_name').notNullable();    })    .table('subject', function(table) {      table.string('subject_key_name').notNullable();    })    .table('lesson', function(table) {      table.string('lesson_key_name').notNullable();    });}; ---File: 20240323043227_add_daily_quizzes_column_to_player.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.table('player', function(table) {      // Set default value to 0 for the daily quiz count without comment      table.integer('player_daily_quiz_count').defaultTo(0);      table.timestamp('player_last_daily_quiz_count_reset').defaultTo(null);      // Add a new column for the lifetime quiz count without comment      table.integer('player_lifetime_quiz_count').defaultTo(0);    });};/** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.down = function(knex) {    return knex.schema.table('player', function(table) {      table.dropColumn('player_daily_quiz_count');      table.dropColumn('player_last_daily_quiz_count_reset');      // Remove the lifetime quiz count column      table.dropColumn('player_lifetime_quiz_count');    });}; ---File: 20240324140642_add_room_table.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.createTable('room', function(table) {      table.increments('room_id').primary(); // Primary key for the room, with naming convention      table.string('room_code').notNullable().unique(); // Room code, unique           table.integer('room_subject_id').notNullable().unsigned() // Reflects subjectId, with naming convention        .references('subject_id').inTable('subject') // Foreign key referencing subject_id in subject table        .onUpdate('CASCADE') // If the referenced subject_id changes, update it here as well        .onDelete('CASCADE'); // If the referenced subject is deleted, delete this room              table.integer('room_lesson_id').notNullable().unsigned() // Reflects lessonId, with naming convention        .references('lesson_id').inTable('lesson') // Foreign key referencing lesson_id in lesson table        .onUpdate('CASCADE') // If the referenced lesson_id changes, update it here as well        .onDelete('CASCADE'); // If the referenced lesson is deleted, delete this room             table.boolean('room_active').defaultTo(true); // Boolean flag for isFinished      table.jsonb('room_data').defaultTo('{}'); // JSONB column to store a variety of room-related data      table.jsonb('player_ids').defaultTo('[]'); // JSONB column to store array of player IDs      table.timestamps(true, true); // Adds created_at and updated_at columns    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.dropTable('room'); // Drops the room table if the migration is rolled back  };   ---File: 20240409084600_add_lesson_sections_column.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.table('lesson', function(table) {      table.jsonb('lesson_sections');      table.timestamp('sections_updated_at').defaultTo(knex.fn.now());    })    .then(() => {      // Create the update_timestamp function      return knex.raw(`        CREATE OR REPLACE FUNCTION update_timestamp()        RETURNS TRIGGER AS $$        BEGIN          NEW.sections_updated_at := CURRENT_TIMESTAMP;          RETURN NEW;        END;        $$ LANGUAGE plpgsql;      `);    })    .then(() => {      // Create a trigger to update the 'sections_updated_at' column      return knex.raw(`        CREATE TRIGGER update_lesson_sections_timestamp        BEFORE UPDATE ON lesson        FOR EACH ROW        WHEN (OLD.lesson_sections IS DISTINCT FROM NEW.lesson_sections)        EXECUTE PROCEDURE update_timestamp();      `);    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.table('lesson', function(table) {      // First, drop the trigger      return knex.raw('DROP TRIGGER IF EXISTS update_lesson_sections_timestamp ON lesson;');    })    .then(() => {      // Then, drop the sections_updated_at column      return knex.schema.table('lesson', function(table) {        table.dropColumn('sections_updated_at');      });    })    .then(() => {      // Finally, drop the lesson_sections column      return knex.schema.table('lesson', function(table) {        table.dropColumn('lesson_sections');      });    })    .then(() => {      // Drop the update_timestamp function      return knex.raw('DROP FUNCTION IF EXISTS update_timestamp();');    });  }; ---File: 20240409112221_create_quiz_tabe.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.createTable('quiz', function(table) {      table.increments('quiz_id').primary();      table.timestamp('quiz_timestamp').defaultTo(knex.fn.now());      table.integer('room_id').unsigned().notNullable();      table.integer('lesson_id').unsigned().notNullable();      table.string('quiz_lesson_section_title');      table.string('quiz_lesson_hash');      table.string('quiz_prompt_hash');      // New column: quiz_json (jsonb)      table.jsonb('quiz_json');         // Foreign key constraints      table.foreign('room_id').references('room_id').inTable('room');      table.foreign('lesson_id').references('lesson_id').inTable('lesson');    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.dropTableIfExists('quiz');  }; ---File: 20240409124957_add_quiz_id_column_to_room_table.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.table('room', function(table) {      table.integer('quiz_id').unsigned().nullable();      table.foreign('quiz_id').references('quiz_id').inTable('quiz').onDelete('SET NULL');    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.table('room', function(table) {      table.dropForeign('room_quiz_id_foreign'); // Drop the foreign key constraint      table.dropColumn('quiz_id'); // Drop the 'quiz_id' column    });  }; ---File: 20240409144343_change_room_table_columns.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.alterTable('room', function(table) {      table.renameColumn('room_subject_id', 'subject_id');      table.renameColumn('room_lesson_id', 'lesson_id');      table.foreign('subject_id').references('subject_id').inTable('subject');      table.foreign('lesson_id').references('lesson_id').inTable('lesson');    })    .then(() => {      return knex.raw('ALTER TABLE room DROP COLUMN player_ids, ADD COLUMN player_ids integer[]');    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.alterTable('room', function(table) {      table.dropForeign('subject_id');      table.dropForeign('lesson_id');        knex.raw('ALTER TABLE room DROP COLUMN IF EXISTS player_ids');      knex.raw('ALTER TABLE room ADD COLUMN player_ids jsonb');      table.renameColumn('subject_id', 'room_subject_id');      table.renameColumn('lesson_id', 'room_lesson_id');    });  }; ---File: 20240409160505_change_room_table_room_code.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.raw(      `      ALTER TABLE room DROP CONSTRAINT IF EXISTS room_code_unique;      ALTER TABLE room DROP CONSTRAINT IF EXISTS room_room_code_unique;      `    );  };    exports.down = function(knex) {    return knex.raw(      `ALTER TABLE room ADD CONSTRAINT room_code_unique UNIQUE (room_code);`    );  }; ---File: 20240409163756_add_new_column_to_room_table.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {  return knex.schema.table('room', function(table) {    table.string('quiz_source');  });};/** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.down = function(knex) {  return knex.schema.table('room', function(table) {    table.dropColumn('quiz_source');  });}; ---File: 20240411172758_create_quiz_room_player_junction_table.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.createTable('quiz_player_room', function(table) {      table.increments('id').primary();      table.integer('room_id').unsigned().notNullable();      table.foreign('room_id').references('room.room_id');      table.integer('quiz_id').unsigned().notNullable();      table.foreign('quiz_id').references('quiz.quiz_id');      table.integer('player_id').unsigned().notNullable();      table.foreign('player_id').references('player.player_id');      table.timestamp('timestamp', { useTz: true }).defaultTo(knex.fn.now());      table.string('quiz_source');    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.dropTable('quiz_player_room');  }; ---File: 20240411180908_remove_quiz_id_column_from_room_table.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {  return knex.schema.table('room', function(table) {    table.dropForeign('quiz_id'); // Drop the foreign key constraint for 'quiz_id'    table.dropColumn('quiz_id'); // Drop the 'quiz_id' column    table.dropColumn('quiz_source'); // Drop the 'quiz_source' column  });};/** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.down = function(knex) {  return knex.schema.table('room', function(table) {    table.integer('quiz_id').unsigned().nullable(); // Re-add the 'quiz_id' column    table.foreign('quiz_id').references('quiz_id').inTable('quiz').onDelete('SET NULL'); // Re-add the foreign key constraint for 'quiz_id'    table.string('quiz_source'); // Re-add the 'quiz_source' column  });}; ---File: 20240414180337_add_grade_hidden_column.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {  return knex.schema.table('grade', function(table) {    table.boolean('grade_hidden').defaultTo(false);  });};/** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.down = function(knex) {  return knex.schema.table('grade', function(table) {    table.dropColumn('grade_hidden');  });}; ---File: 20240417232930_add_hidden_column_to_subjects.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = async function(knex) {  await knex.schema.table('subject', function(table) {    table.boolean('subject_hidden').defaultTo(false);  });};/** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.down = async function(knex) {  await knex.schema.table('subject', function(table) {    table.dropColumn('subject_hidden');  });}; ---File: 20240419163747_create_activity_log.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.createTable('activity_log', function(table) {      table.increments('activity_log_id').primary(); // Auto-incrementing primary key for each log entry, prefixed with table name      table.string('activity_log_name').notNullable(); // Column to store the name of the log entry, for example, "User Signup", "Quiz Played"      table.jsonb('activity_log_data').nullable(); // JSONB column for storing additional details about the activity, prefixed with table name      table.timestamp('activity_log_timestamp').defaultTo(knex.fn.now()); // Timestamp of when the activity was logged, prefixed with table name    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.dropTable('activity_log'); // Drops the activity_log table  };   ---File: 20240419222311_add_lesson_play_count.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {    return knex.schema.table('lesson', function(table) {      table.dropColumn('sections_updated_at');  // Remove the column      table.integer('lesson_play_count').defaultTo(0);  // Add a new integer column with default value    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = function(knex) {    return knex.schema.table('lesson', function(table) {      table.timestamp('sections_updated_at').defaultTo(knex.fn.now());  // Add the column back with a default value      table.dropColumn('lesson_play_count');  // Remove the new column    });  };   ---File: 20240426044422_add_clash_table.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = async function(knex) {    await knex.schema.createTable('clash', function(table) {      table.increments('clash_id').primary();      table.integer('room_id').unsigned().notNullable();      table.integer('quiz_id').unsigned().notNullable();      table.integer('clash_quiz_completion_percentage').unsigned().notNullable();      table.integer('clash_duration').unsigned().notNullable(); // Duration in seconds      table.timestamp('clash_timestamp').defaultTo(knex.fn.now()); // Timestamp when the clash was created        // Foreign keys      table.foreign('room_id').references('room_id').inTable('room');      table.foreign('quiz_id').references('quiz_id').inTable('quiz');    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = async function(knex) {    await knex.schema.dropTableIfExists('clash');  }; ---File: 20240426051107_add_clash_start_timestamp_in_room_table.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = async function(knex) {    await knex.schema.alterTable('room', function(table) {      table.dropColumn('updated_at');    });  };    /**   * @param { import("knex").Knex } knex   * @returns { Promise<void> }   */  exports.down = async function(knex) {    await knex.schema.alterTable('room', function(table) {      table.timestamp('updated_at').defaultTo(knex.fn.now());    });  };   ---File: 20240426093403_remove_junction_table_quiz_player_room.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {  return knex.schema.dropTable('quiz_player_room');};/** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.down = function(knex) {  return knex.schema.createTable('quiz_player_room', function(table) {    table.increments('id').primary();    table.integer('room_id').unsigned().notNullable();    table.foreign('room_id').references('room.room_id');    table.integer('quiz_id').unsigned().notNullable();    table.foreign('quiz_id').references('quiz.quiz_id');    table.integer('player_id').unsigned().notNullable();    table.foreign('player_id').references('player.player_id');    table.timestamp('timestamp', { useTz: true }).defaultTo(knex.fn.now());    table.string('quiz_source');  });}; ---File: 20240426094324_add_player_bot_column.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {  return knex.schema.table('player', function(table) {    table.boolean('player_bot').defaultTo(false);  });};/** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.down = function(knex) {  return knex.schema.table('player', function(table) {    table.dropColumn('player_bot');  });}; ---File: 20240426101107_add_player_ids_column_to_clash_table.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {  return knex.schema.table('clash', function(table) {    table.specificType('clash_player_ids', 'integer[]').defaultTo('{}');  });};/** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.down = function(knex) {  return knex.schema.table('clash', function(table) {    table.dropColumn('clash_player_ids');  });}; ---File: 20240426101831_rename_room_table_columns.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {  return knex.schema.table('room', function(table) {    table.renameColumn('player_ids', 'room_player_ids');    table.renameColumn('created_at', 'room_created_at');  });};/** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.down = function(knex) {  return knex.schema.table('room', function(table) {    table.renameColumn('room_player_ids', 'player_ids');    table.renameColumn('room_created_at', 'created_at');  });}; ---File: 20240427075905_add_timestamp_to_subject_grade_lesson.js --- /** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.up = function(knex) {  return Promise.all([    knex.schema.table('grade', function(table) {      table.timestamp('grade_timestamp').defaultTo(knex.fn.now());    }),    knex.schema.table('subject', function(table) {      table.timestamp('subject_timestamp').defaultTo(knex.fn.now());    }),    knex.schema.table('lesson', function(table) {      table.timestamp('lesson_timestamp').defaultTo(knex.fn.now());    })  ]);};/** * @param { import("knex").Knex } knex * @returns { Promise<void> } */exports.down = function(knex) {  return Promise.all([    knex.schema.table('grade', function(table) {      table.dropColumn('grade_timestamp');    }),    knex.schema.table('subject', function(table) {      table.dropColumn('subject_timestamp');    }),    knex.schema.table('lesson', function(table) {      table.dropColumn('lesson_timestamp');    })  ]);}; ---File: deploy.sh --- #!/bin/bash# Deployment script steps:# 1. Conditionally run Jest tests if -t flag is provided.# 2. Fetch and merge 'dev' into 'prod' on server.# 3. Install server dependencies.# 4. Run Knex migrations.# 5. Restart server with PM2 and show logs.# Check for uncommitted changes in the dev branchecho -e "\n\033[34mCHECKING for uncommitted changes in dev branch...\033[0m\n"git checkout dev > /dev/null 2>&1if ! git diff-index --quiet HEAD --; then  echo -e "\n\033[31mYou have uncommitted changes in the dev branch. Please commit or stash them before deploying.\033[0m\n"  exit 1fi# Initial flag valuesRUN_TESTS=false# Check script arguments for -test flagwhile getopts ":t" opt; do  case ${opt} in    t ) # Process option for running tests      RUN_TESTS=true      ;;    \? ) echo "Usage: cmd [-t]"      ;;  esacdoneif [ "$RUN_TESTS" = true ]; then  echo -e "\n\033[34mRUNNING Jest tests...\033[0m\n"  npm run test   TEST_STATUS=$?  if [ $TEST_STATUS -ne 0 ]; then    echo -e "\n\033[31mTests FAILED. Exiting...\033[0m\n"    exit $TEST_STATUS  else    echo -e "\n\033[32mTests passed. Proceeding with deployment...\033[0m\n"  fifi  SSH_HOST="root@104.248.142.129"  SSH_DIR="~/class-clash-backend"  echo -e "\n\033[34mFETCHING latest changes...\033[0m\n"  if ! ssh $SSH_HOST "cd $SSH_DIR && git fetch origin"; then    echo -e "\n\033[31mFAILED to fetch changes. Exiting...\033[0m\n"    exit 1  fiecho -e "\n\033[34mMERGING dev into prod on the server...\033[0m\n"if ! ssh $SSH_HOST "cd $SSH_DIR && git checkout prod && git merge origin/dev -m 'Merging changes from dev to prod' && git push origin prod"; then  echo -e "\n\033[31mMerge or push FAILED. Exiting...\033[0m\n"  exit 1fiecho -e "\n\033[34mINSTALLING dependencies on the server...\033[0m\n"if ! ssh $SSH_HOST "cd $SSH_DIR && npm install"; then  echo -e "\n\033[31mDependency installation FAILED. Creating a revert commit for the merge and exiting...\033[0m\n"  ssh $SSH_HOST "cd $SSH_DIR && git revert -m 1 HEAD && git push origin prod"  exit 1fiecho -e "\n\033[34mAPPLYING knex database migrations...\033[0m\n"if ! ssh $SSH_HOST "cd $SSH_DIR && npm run migrate-prod"; then  echo -e "\n\033[31mDatabase migration failed. Creating a revert commit for the merge and exiting...\033[0m\n"  ssh $SSH_HOST "cd $SSH_DIR && git revert -m 1 HEAD && git push origin prod"  exit 1fi  echo -e "\n\033[34mRESTARTING PM2...\033[0m\n"  if ! ssh $SSH_HOST "cd $SSH_DIR && (pm2 reload server || pm2 start server.js --name server) && pm2 logs"; then    echo -e "\n\033[31mPM2 restart/logs FAILED. Please check manually.\033[0m\n"  fifi ---File: package.json --- {  "dependencies": {    "@google-cloud/vertexai": "^1.0.0",    "@sendgrid/mail": "^8.1.1",    "app-root-path": "^3.1.0",    "axios": "^1.6.7",    "cli-color": "^2.0.3",    "cors": "^2.8.5",    "crypto": "^1.0.1",    "dotenv": "^16.4.5",    "express": "^4.18.2",    "facebook-nodejs-business-sdk": "^19.0.3",    "firebase-admin": "^12.0.0",    "https-proxy-agent": "^5.0.1",    "jest": "^29.7.0",    "knex": "^3.1.0",    "node-cron": "^3.0.3",    "pg": "^8.11.3",    "socket.io": "^4.7.4",    "socket.io-client": "^4.7.5",    "supertest": "^6.3.4"  },  "scripts": {    "start": "node server.js",    "migrate-prod": "node -r dotenv/config ./node_modules/.bin/knex --knexfile ./db/knexfile.js migrate:latest",    "migrate-dev": "knex --knexfile ./db/knexfile.js migrate:latest",    "rollback-prod": "node -r dotenv/config ./node_modules/.bin/knex --knexfile ./db/knexfile.js migrate:rollback",    "rollback-dev": "knex --knexfile ./db/knexfile.js migrate:rollback",    "test": "jest --forceExit"  },  "name": "class-clash-backend",  "version": "1.0.0",  "main": "server.js",  "author": "",  "license": "ISC",  "description": ""} ---File: quizRoomManager.js --- const socketIO = require('socket.io');const getQuizWithoutCorrectAnswers = require('./utilities/getQuizWithoutCorrectAnswers');const addXpToPlayerTotal = require('./utilities/addXpToPlayerTotal');const incrementPlayerQuizCounts = require('./utilities/incrementPlayerQuizCounts');const generateMultipleChoiceQuizObject = require('./utilities/generateMultipleChoiceQuizObject');const getLessonById = require('./utilities/getLessonById');const clc = require('cli-color');const db = require('./db/db');const { USE_TEST_QUIZ, QUESTION_TIMER_DURATION, CORRECT_ANSWER_XP, DELAY_BEFORE_NEXT_QUESTION, ROOM_CODE_WORDS, TEST_QUIZ } = require('./constants');const addQuizToDatabase = require('./utilities/addQuizToDatabase');const generateHashFromText = require('./utilities/generateHashFromText');const addActivityLog = require('./utilities/addActivityLog');const incrementLessonPlayCount = require('./utilities/incrementLessonPlayCount');const getRandomBotUser = require('./utilities/getBotUser');const deepUpdateInMemoryObject = require('./utilities/deepUpdateInMemoryObject');const addClashDetailsToDatabase = require('./utilities/addClashDetailsToDatabase');const botPlayerInteractsInChat = require('./utilities/botPlayerInteractsInChat');const generateRoomCode = require('./utilities/generateRoomCode');const activeTimeouts = {};//when we fetch the room for the first time, we store it in the rooms set so it's available globally. and whenver we updated the room, we update the room in the set as well.const rooms = {}const determineWinnersAndRewardXp = async ({ roomCode }) => {    const room = await getRoomByCode(roomCode);    const maxXP = Math.max(...room.room_data.playersData.map(player => player.xp));    const updatedPlayersData = room.room_data.playersData.map(player => {        if (maxXP === 0) {            return { ...player, isWinner: false };        } else {            const isWinner = player.xp === maxXP;            const xp = player.xp//isWinner ? player.xp : Math.max(Math.floor(player.xp * 0.1), 5);            return { ...player, isWinner, xp };        }    });    await updateRoom({        roomCode: room.room_code,        path: "room_data.playersData",        newValue: updatedPlayersData    });};const startTimer = async ({ io, roomCode }) => {    // Clear existing timeout if any    if (activeTimeouts[roomCode]) {        console.log(`${clc.bgWhite.black(roomCode)}: Clearing existing timeouts`);        clearTimeout(activeTimeouts[roomCode]);        activeTimeouts[roomCode] = null;    }        //if room is not active then return         const room = await getRoomByCode(roomCode);        if (!room || !room.room_active){            console.log(`${clc.bgWhite.black(roomCode)}: Room is not active, stopping timer.`);            return;        }    // Calculate the nextQuestionTimestamp    const nextQuestionTimestamp = Date.now() + QUESTION_TIMER_DURATION * 1000;    // Update room_data with nextQuestionTimestamp    await updateRoom({        roomCode,        path: "room_data.nextQuestionTimestamp",        newValue: nextQuestionTimestamp    });    setTimeout(async () => {        await botPlayerChoosesAnswer({ io, roomCode });    }, Math.floor(Math.random() * (3000 - 1000 + 1) + 1000));    // Schedule moveToNextQuestionOrEndQuiz and save the timeout ID    activeTimeouts[roomCode] = setTimeout(async () => {        console.log(`${clc.bgWhite.black(roomCode)}: ${clc.yellow('TIME IS UP')}`)        await moveToNextQuestionOrEndQuiz({ roomCode, io, fillMissingAnswers: true });    }, QUESTION_TIMER_DURATION * 1000);};const checkIfAnswerIsCorrect = async ({ io, roomCode, answerIndex, playerId }) => {    let room = await getRoomByCode(roomCode);    let currentQuestionIndex = room.room_data.currentQuestionIndex;    // Assuming `isCorrect` determination does not require an updated room object.    const isCorrect = room.room_data.quiz.correctAnswers[currentQuestionIndex].includes(answerIndex);    //check if this is a bot player basedo n player id     const isBotPlayer = room.room_data.playersData.some(player => player.basicPlayerData.player_id === playerId && player.isBot);    // Update the answer immediately if it's a new entry.    await updateRoom({        roomCode: room.room_code,        path: `room_data.answers[${currentQuestionIndex}].playersAnswers.${playerId}`,        newValue: { answerIndex, isCorrect }    });    console.log(`${clc.bgWhite.black(room.room_code)}: Player ${clc.blue(playerId)} answer is ${isCorrect ? clc.green('correct') : clc.red('wrong')}`);    // Update player XP if the answer is correct    if (isCorrect) {        // Find the player and update XP        const playerIndex = room.room_data.playersData.findIndex(player => player.basicPlayerData.player_id === playerId);        if (playerIndex !== -1) {            // Persist the updated XP            await updateRoom({                roomCode: room.room_code,                path: `room_data.playersData[${playerIndex}].xp`,                newValue: room.room_data.playersData[playerIndex].xp += CORRECT_ANSWER_XP            });            console.log(`${clc.bgWhite.black(room.room_code)}: Awarded ${CORRECT_ANSWER_XP} XP to player ${clc.blue(playerId)}`);        }    }}const handleMissingAnswers = async ({ roomCode }) => {    let room = await getRoomByCode(roomCode);    const currentQuestionIndex = room.room_data.currentQuestionIndex;    console.log(`${clc.bgWhite.black(roomCode)}: Checking if all players have answered the current question.`);    // Convert forEach to use Promise.all for async operations    await Promise.all(room.room_data.playersData.map(async (playerData) => {        const playerId = playerData.basicPlayerData.player_id;        console.log(`${clc.bgWhite.black(roomCode)}: ${clc.blue('Checking for missing answers for player')} ${playerId}`);        if (!room.room_data.answers[currentQuestionIndex].playersAnswers[playerId]) {            console.log(`${clc.bgWhite.black(roomCode)}: ${clc.red('Missing answer recorded for player')} ${clc.blue(playerId)}`);            await updateRoom({                roomCode: room.room_code,                path: `room_data.answers[${currentQuestionIndex}].playersAnswers.${playerId}`,                newValue: { answerIndex: null, isCorrect: false, isMissing: true }            });        } else {            console.log(`${clc.bgWhite.black(roomCode)}: ${clc.green('Answer found for player')} ${clc.blue(playerId)} : ${JSON.stringify(room.room_data.answers[currentQuestionIndex].playersAnswers[playerId])}`);        }    }));}const moveToNextQuestionOrEndQuiz = async ({ roomCode, io, fillMissingAnswers = false }) => {    let room = await getRoomByCode(roomCode);    const currentQuestionIndex = room.room_data.currentQuestionIndex;    const nextQuestionIndex = room.room_data.currentQuestionIndex + 1;    if (fillMissingAnswers) await handleMissingAnswers({ roomCode });    const currentQuestionAnswers = room.room_data.answers[currentQuestionIndex];    const answersCount = Object.keys(room.room_data.answers[currentQuestionIndex].playersAnswers).length;    //if all players have answered the question    console.log(`${clc.bgWhite.black(room.room_code)}: checking if all players answreed current question. answersCount: ${clc.blue(answersCount)} playersDataLength: ${clc.blue(room.room_data.playersData.length)}`)    if (answersCount === room.room_data.playersData.length) {             console.log(`${clc.bgWhite.black(room.room_code)}: ${clc.yellow(`MOVING to the next question ${clc.blue(currentQuestionIndex)}. Time is up or all players answered`)}`);        if (activeTimeouts[roomCode]) {            clearTimeout(activeTimeouts[roomCode]);            delete activeTimeouts[roomCode];        }        const hasNextQuestion = room.room_data.currentQuestionIndex < room.room_data.quiz.questions.length - 1;        if (hasNextQuestion) {                        await updateRoom({                roomCode: room.room_code,                path: 'room_data.currentQuestionIndex',                newValue: nextQuestionIndex            });            await updateRoom({                roomCode: room.room_code,                path: `room_data.answers[${nextQuestionIndex}]`,                newValue: {                    questionIndex: nextQuestionIndex,                    playersAnswers: {},                    correctAnswersIndexes: room.room_data.quiz.correctAnswers[nextQuestionIndex]                }            });            io.in(roomCode).emit('question_finished', { currentQuestionAnswers });                    setTimeout(async () => {                io.in(roomCode).emit('next_question', {                    nextQuestionIndex: room.room_data.currentQuestionIndex,                    timer: QUESTION_TIMER_DURATION                });                await startTimer({ io, roomCode: room.room_code });            }, DELAY_BEFORE_NEXT_QUESTION);            const botExists = room.room_data.playersData.some(player => player.isBot);            if (botExists) {                const botPlayer = room.room_data.playersData.find(player => player.isBot);                const botAnswerForCurrentQuestion  = room.room_data.answers[currentQuestionIndex].playersAnswers[botPlayer.basicPlayerData.player_id]                const botPlayerIsCorrect = botAnswerForCurrentQuestion?.isCorrect;                                if (botPlayerIsCorrect) {                     botPlayerInteractsInChat({ io, room, scenario: 'bot_player_correct_answer' });                } else {                       botPlayerInteractsInChat({ io, room, scenario: 'bot_player_wrong_answer' });                    }            }        } else { // End of quiz            console.log(`${clc.bgWhite.black(room.room_code)}: ${clc.yellow('QUIZ ENDED, we reached GAME OVER screen')}`);            io.in(roomCode).emit('question_finished', { currentQuestionAnswers });            await determineWinnersAndRewardXp({ roomCode });            const playersResults = room.room_data.playersData.map(player => ({                playerId: player.basicPlayerData.player_id,                isWinner: player.isWinner,                xpWon: player.xp            }));            if(!room.room_data.isGameOver) await addClashDetailsToDatabase({room});            await updateRoom({                roomCode: room.room_code,                path: 'room_data.isGameOver',                newValue: true            });                        playersResults.forEach(async (playerResult) => {                if (playerResult.isWinner) {                    await addXpToPlayerTotal({ playerId: playerResult.playerId, xpToAdd: playerResult.xpWon });                    const playerData = room.room_data.playersData.find(player => player.basicPlayerData.player_id === playerResult.playerId);                    if (playerData && playerData.isBot) {                        io.to(roomCode).emit('receive_message', { message: "!ولياي ",playerId: playerResult.playerId });                    }                }            });            await new Promise(resolve => setTimeout(resolve, DELAY_BEFORE_NEXT_QUESTION));                                    io.in(roomCode).emit('quiz_end', { currentQuestionAnswers, timer: 0, playersResults });        }    }}const handlePlayerQuitting = async ({ io, roomCode, playerId }) => {    const room = await getRoomByCode(roomCode);    if (!room || !room?.room_active) return    if (room.room_active) {        room.room_data.playersData.forEach(async (player) => {            let statusKey = player.basicPlayerData.player_id === playerId ? 'isQuit' : 'isWinner';            if (statusKey === 'isQuit' && !player[statusKey]) {                await updateRoom({                    roomCode: room.room_code,                    path: `room_data.playersData[${room.room_data.playersData.indexOf(player)}].${statusKey}`,                    newValue: true                });            }            if (statusKey === 'isQuit') {                console.log(`${clc.bgWhite.black(room.room_code)}: Player ${clc.blue(playerId)} has ${clc.red('quit')} the game.`);                io.to(room.room_code).emit('player_quit', { playerId });            } else {                if (!room.room_data.isGameOver) {                    await addXpToPlayerTotal({ playerId: player.basicPlayerData.player_id, xpToAdd: player.xp });                }            }        });    }    // Clear the timeout if the player quits    if (activeTimeouts[room.room_code]) {        clearTimeout(activeTimeouts[room.room_code]);        delete activeTimeouts[room.room_code];        console.log(`${clc.bgWhite.black(room.room_code)}: Cleared active timeout for room.`);    }    // Refactored function to handle room deactivation and deletion    const deactivateAndDeleteRoom = async (roomCode) => {        await updateRoom({ roomCode: roomCode, path: 'room_active', newValue: false });        delete rooms[roomCode];        console.log(`${clc.bgWhite.black(roomCode)}: ${clc.red('Room is now INACTIVE and DELETED from memory.')}`);    };    // Check if all non-bot players have quit    if (room.room_data.playersData.every(playerData => playerData.isQuit || playerData.isBot)) {        console.log(`${clc.bgWhite.black(room.room_code)}: ${clc.yellow('All non-bot players have quit the game.')}`);        await deactivateAndDeleteRoom(room.room_code);        if(!room.room_data.isGameOver) await addClashDetailsToDatabase({room});        return;    }    // Check if there was only one player who quit    if (room.room_data.playersData.length === 1) {        console.log(`${clc.bgWhite.black(room.room_code)}: ${clc.yellow('Single player in the room has quit.')}`);        await deactivateAndDeleteRoom(room.room_code);        return;    }    const playersResults = room.room_data.playersData.map(player => ({        playerId: player.basicPlayerData.player_id,        isWinner: player.isWinner,        xpWon: player.xp    }));    if(!room.room_data.isGameOver) await addClashDetailsToDatabase({room});    await updateRoom({        roomCode: room.room_code,        path: 'room_data.isGameOver',        newValue: true    });    io.in(room.room_code).emit('quiz_end', {        currentQuestionAnswers: room.room_data.answers[room.room_data.currentQuestionIndex],        timer: 0,        playersResults    });}async function generateQuizAndAddItToRoom({ roomCode, selectedLessonSectionTitle }) {    try {        const room = await getRoomByCode(roomCode);        if (!room) {            throw new Error(`Room with code ${roomCode} not found.`);        }        let quiz;        if (USE_TEST_QUIZ) {            quiz = TEST_QUIZ;        } else {            try {                const lesson = await getLessonById(room.lesson_id);                if (!lesson) {                    throw new Error(`Lesson with ID ${room.lesson_id} not found.`);                }                const lessonSections = lesson.lesson_sections;                let selectedSection;                if (selectedLessonSectionTitle.toLowerCase() === "random") {                    selectedSection = lessonSections?.sections[Math.floor(Math.random() * lessonSections?.sections.length)];                    console.log(`${clc.blue('Random section selected')}: ${clc.yellow(selectedSection?.sectionTitle)}`);                } else {                    selectedSection = lessonSections?.sections.find(section => section.sectionTitle === selectedLessonSectionTitle);                    if (!selectedSection) {                        console.log(`${clc.red('Section titled')} ${clc.yellow(selectedLessonSectionTitle)} ${clc.red('not found. Selecting a random section.')}`);                        selectedSection = lessonSections?.sections[Math.floor(Math.random() * lessonSections?.sections.length)];                    }                    console.log(`${clc.blue('Selected section')}: ${clc.yellow(selectedSection?.sectionTitle)}`);                }                await updateRoom({                    roomCode: roomCode,                    path: "room_data.selectedLessonSection",                    newValue: selectedSection                });                const { newQuiz, quizId, prompt } = await generateMultipleChoiceQuizObject({                    lessonContent: lesson.lesson_content,                    selectedLessonSection: room.room_data.selectedLessonSection,                    playerIds: room.room_player_ids,                    lessonId: room.lesson_id,                    lessonTitle: lesson.lesson_display_name                });                quiz = newQuiz;                if (!quizId) {                    //if we do not have quizId, it means this is a new quiz generated by the AI, and doesnt exist in the database yet.                    const quizDatabaseResponse = await addQuizToDatabase({                        lesson_id: room.lesson_id,                        room_id: room.room_id,                        quiz_lesson_section_title: selectedSection?.sectionTitle,                        quiz_lesson_hash: generateHashFromText(JSON.stringify(lesson.lesson_content)),                        quiz_prompt_hash: generateHashFromText(JSON.stringify(prompt)),                        quiz_json: JSON.stringify(quiz)                    });                    //add quizDatabaseResponse?.quiz_id to the room object                    await updateRoom({                        roomCode: roomCode,                        path: "room_data.quiz_id",                        newValue: quizDatabaseResponse.quiz_id                    });                    await updateRoom({                        roomCode: roomCode,                        path: "room_data.quiz_source",                        newValue: 'ai_generated'                    });                } else {                    //if we have quizId, it means we are using an existing quiz from the database.                    //add quizId to the room object                    await updateRoom({                        roomCode: roomCode,                        path: "room_data.quiz_id",                        newValue: quizId                    });                    await updateRoom({                        roomCode: roomCode,                        path: "room_data.quiz_source",                        newValue: 'reused_quiz'                    });                }                console.log(`${clc.bgWhite.black(roomCode)}: ${clc.green('Quiz generated successfully')}`);            } catch (error) {                console.log(error)                throw new Error(`Error generating quiz: ${error.message}`);            }        }        if (room.room_active) {            // Update the room object with the new quiz            await updateRoom({ roomCode, path: "room_data.quiz", newValue: (quiz) });            await updateRoom({                roomCode,                path: `room_data.answers[0].correctAnswersIndexes`,                newValue: quiz.correctAnswers['0']            });        } else {            console.log(`${clc.bgWhite.black(roomCode)}: ${clc.red('Room is not active, DID  NOT update room with new quiz.')}`);            console.log(room)        }    } catch (error) {        console.error(`Failed to update room with new quiz for roomCode ${roomCode}: ${error.message}`);    }}async function initializeRoom({ roomCode, subjectId, lessonId, socket, basicPlayerData }) {    try {        const existingRoom = await getRoomByCode(roomCode);        if (existingRoom && existingRoom.room_active) {            console.log(`${clc.bgWhite.black(roomCode)}: Initializing ${clc.yellow('EXISTING')} room.`);            // Room exists, reset specific fields but preserve quiz history            const roomData = existingRoom.room_data;            const previousQuestions = roomData.quiz ? roomData.quiz.questions.map(q => q.question) : [];            roomData.quiz = null; // Assume you'll set the new quiz later            roomData.currentQuestionIndex = 0;            roomData.answers = {                0: //index of the question                {                    questionIndex: 0, playersAnswers: {},                    correctAnswersIndexes: []                } // Initially empty            };            roomData.timer = null;            roomData.replayRequestedBy = null;            roomData.isGameOver = false;            roomData.playersData.forEach(player => player.xp = 0);            roomData.previousQuizQuestions = [...roomData.previousQuizQuestions, ...previousQuestions].slice(-15); // Keep last 15 questions            await updateRoom({                roomCode: roomCode,                path: "room_data",                newValue: JSON.stringify(roomData)            });        } else {            console.log(`${clc.bgWhite.black(roomCode)}: Initializing ${clc.yellow('NEW')} room.`);            // Room doesn't exist, create it with initial values            await db('room').insert({                room_code: roomCode,                subject_id: subjectId,                lesson_id: lessonId,                room_active: true,                room_data: JSON.stringify({                    quiz: null,                    playersData: [{ socketId: socket.id, basicPlayerData, xp: 0 }], // Assume adding basicPlayerData elsewhere                    currentQuestionIndex: 0,                    answers: {                        0: //index of the question                            { questionIndex: 0, playersAnswers: {}, correctAnswersIndexes: [] } // Initially empty                    },                    timer: null,                    isGameOver: false,                    replayRequestedBy: null,                    previousQuizQuestions: [] // Initially empty                }),                room_player_ids: [basicPlayerData.player_id] // Storing initial player's socket ID            });            //delete the room from the rooms object if it exists            if (rooms[roomCode]) {                delete rooms[roomCode];            }        }    } catch (err) {        console.error(`${clc.bgWhite.black(roomCode)}: ${clc.red('Error initializing room:' + err.message)}`);    }}async function getRoomByCode(roomCode) {    try {        if (rooms[roomCode]) {            // Check if room_data is a string before parsing            if (typeof rooms[roomCode].room_data === 'string') {                rooms[roomCode].room_data = JSON.parse(rooms[roomCode].room_data);            }            return rooms[roomCode];        } else {            const room = await db('room').where({ room_code: roomCode }).first();            if (!room) {                console.log(`${clc.bgWhite.black(roomCode)}: ${clc.blue(`Room with code ${roomCode} not found.`)}`);                return null;            }            // Check if room_data is a string before parsing            if (typeof room.room_data === 'string') {                room.room_data = JSON.parse(room.room_data); // Parse room_data before adding to the object            }            rooms[roomCode] = room; // Add room to the object            return rooms[roomCode];        }    } catch (err) {        console.error(`Error retrieving room ${roomCode}:`, err.message);        return null;    }}async function updateRoom({ roomCode, path, newValue }) {    try {        // Update the in-memory object first        const isJsonbUpdate = path.startsWith("room_data.");        if (isJsonbUpdate) {            // Assuming a function to deep update your in-memory object if the path points to nested properties            deepUpdateInMemoryObject(rooms[roomCode], path.split('.'), newValue);        } else {            // For non-nested properties, update directly            rooms[roomCode][path] = newValue;        }        // Now, initiate database update without waiting for it to finish        if (isJsonbUpdate) {            const pathParts = path.split('.').slice(1); // Remove 'room_data' part            const jsonbPath = [];            pathParts.forEach(part => {                if (part.includes('[')) {                    const [key, index] = part.split(/\[|\]/).filter(Boolean);                    jsonbPath.push(key, index);                } else {                    jsonbPath.push(part);                }            });            const formattedPath = `{${jsonbPath.join(',')}}`;            const newValueJsonb = JSON.stringify(newValue);            db('room')                .where({ room_code: roomCode })                .update({                    room_data: db.raw(`jsonb_set(room_data, ?::text[], ?)`, [formattedPath, newValueJsonb])                }, ['*'])                .then(updatedRoomData => {                    //console.log('Database update successful for JSONB path.');                })                .catch(err => {                    console.error('Database update failed for JSONB path:', err);                });        } else {            let updateValue = newValue;            // Check if this is a JSON or JSONB column and newValue is not a string            if (typeof newValue === 'object') {                updateValue = JSON.stringify(newValue);            }            // Now, initiate database update without waiting for it to finish            db('room')                .where({ room_code: roomCode })                .update({ [path]: newValue }, ['*'])                .then(updatedRoomData => {                    //   console.log('Database update successful for direct path.');                })                .catch(err => {                    console.error('Database update failed for direct path:', err);                });        }        const displayValue = JSON.stringify(newValue)?.length > 30 ? `${JSON.stringify(newValue).substring(0, 27)}...` : newValue;        console.log(`${clc.bgWhite.black(roomCode)}: ${clc.blue('UPDATED')}  ${clc.magenta(path)} to :`);        console.log(newValue);        return rooms[roomCode]; // Return the updated in-memory room object.    } catch (err) {        console.error(`Error updating ${path} in room ${roomCode} with newValue ${newValue}:`, err.message);    }}async function handlePlayerRejoin(io, socket, roomCode, playerIdentifier) {    let room = await getRoomByCode(roomCode);    if (!room || !room.room_active) {        console.log(`${clc.bgWhite.black(roomCode)}: Room not found or inactive.`);        return socket.emit('error_occurred', { errorCode: 'ROOM_NOT_FOUND', message: `Room ${roomCode} does not exist or is not currently active.` });    }    console.log(`${clc.bgWhite.black(roomCode)}: Player ${clc.blue(playerIdentifier.email || playerIdentifier.player_id)} already in room, REJOINING.`);    socket.join(roomCode);    const updatedPlayersData = room.room_data.playersData.map(player => {        if (player.basicPlayerData.player_id === playerIdentifier.player_id) {            return { ...player, socketId: socket.id };        }        return player;    });    await updateRoom({        roomCode: roomCode,        path: "room_data.playersData",        newValue: updatedPlayersData    });    console.log(`${clc.bgWhite.black(roomCode)}: Player ${clc.blue(playerIdentifier.email || playerIdentifier.player_id)} RECONNECTED to the socket.`);    const currentQuestionIndex = room.room_data.currentQuestionIndex;    const playersWhoAnswered = Object.keys(room.room_data.answers[currentQuestionIndex].playersAnswers).map(id => parseInt(id));    const playersResults = room.room_data.playersData.map(player => ({        playerId: player.basicPlayerData.player_id,        isWinner: player.isWinner,        xpWon: player.xp    }));    io.in(roomCode).emit('player_rejoined', {        nextQuestionIndex: currentQuestionIndex,        timer: QUESTION_TIMER_DURATION,        playersData: room.room_data.playersData,        isGameOver: room.room_data.isGameOver,        playersWhoAnswered: playersWhoAnswered,        //return playersResults if the game is over        playersResults: room.room_data.isGameOver ? playersResults : undefined,        quiz: getQuizWithoutCorrectAnswers(room.room_data.quiz),        currentQuestionAnswers: playersWhoAnswered.length === room.room_data.playersData.length ? room.room_data.answers[currentQuestionIndex] : undefined,        roomCode    });}const botPlayerChoosesAnswer = async ({ io, roomCode }) => {    let room = await getRoomByCode(roomCode);    if (room.room_data.playersData.some(player => player.isBot)) {        const botPlayer = room.room_data.playersData.find(player => player.isBot);        const currentQuestionIndex = room.room_data.currentQuestionIndex;        const currentQuestion = room.room_data.quiz.questions[currentQuestionIndex];        const correctAnswerIndexes = room.room_data.answers[currentQuestionIndex].correctAnswersIndexes;        const correctAnswerIndex = correctAnswerIndexes.length > 0 ? correctAnswerIndexes[0] : null; // Assuming only one correct answer per question        const answers = currentQuestion.answers;        // Check if the bot has already answered the current question        if (room.room_data.answers[currentQuestionIndex].playersAnswers[botPlayer.basicPlayerData.player_id]) {            console.log(`${clc.bgWhite.black(roomCode)}: Bot player ${clc.blue(botPlayer.basicPlayerData.player_email)} already answered.`);            return;        }        let botAnswerIndex;        if (Math.random() < 0.5) {            botAnswerIndex = correctAnswerIndex;        } else {            let wrongAnswers = answers.map((_, index) => index).filter(index => index !== correctAnswerIndex);            console.log('wrongAnswers')            console.log(wrongAnswers)            botAnswerIndex = wrongAnswers[Math.floor(Math.random() * wrongAnswers.length)];        }        console.log(`${clc.bgWhite.black(roomCode)}: Bot player ${clc.blue(botPlayer.basicPlayerData.player_email)} answered answer ${clc.green(botAnswerIndex)}.`);        await checkIfAnswerIsCorrect({ io, roomCode, answerIndex: botAnswerIndex, playerId: botPlayer.basicPlayerData.player_id });        io.in(roomCode).emit('player_answered', { playerId: botPlayer.basicPlayerData.player_id });        await moveToNextQuestionOrEndQuiz({ roomCode, io, answerIndex: botAnswerIndex });    }}const roomCreationAttempts = {};const quizRoomManager = (server) => {    const io = socketIO(server, {        cors: {            origin: "*",            methods: ["GET", "POST"]        }    });    io.on('connection', (socket) => {        socket.on('create_room', async ({ localStorageRoomCode, subjectId, lessonId, lessonDisplayName, subjectDisplayName, basicPlayerData, selectedLessonSectionTitle }) => {            const playerEmail = basicPlayerData.player_email;            const currentTime = Date.now();            if (localStorageRoomCode) {                //check if the room exists                const existingRoom = await getRoomByCode(localStorageRoomCode);                if (existingRoom && existingRoom.room_active && !existingRoom.room_data.isGameOver) {                    await handlePlayerRejoin(io, socket, localStorageRoomCode, { player_id: basicPlayerData.player_id });                    return;                }            }            const limit = process.env.NODE_ENV === 'development' ? 99 : 3;            const timeLimit = 20000; // 20 seconds            if (!roomCreationAttempts[playerEmail]) {                roomCreationAttempts[playerEmail] = { count: 1, firstAttemptTime: currentTime };            } else {                roomCreationAttempts[playerEmail].count += 1;                const timeDiff = currentTime - roomCreationAttempts[playerEmail].firstAttemptTime;                if (timeDiff < timeLimit && roomCreationAttempts[playerEmail].count > limit) {                    return socket.emit('error_occurred', { errorCode: 'ROOM_CREATION_LIMIT_EXCEEDED', message: `You are creating rooms too quickly. Please wait a bit.` });                }                if (timeDiff >= timeLimit) {                    roomCreationAttempts[playerEmail] = { count: 1, firstAttemptTime: currentTime };                }            }            let roomCode = await generateRoomCode();            console.log(`${clc.bgWhite.black(roomCode)}: Room CREATED by ${clc.blue(playerEmail)} studying in grade  ${clc.blue(basicPlayerData.grade_id + ' (' + basicPlayerData.grade_display_name) + ')'}.`);            socket.join(roomCode);            // Initialize or reset the room            await initializeRoom({ roomCode, subjectId, lessonId, socket, basicPlayerData });            console.log(`${clc.bgWhite.black(roomCode)}: Room initialized with subject ${clc.blue(`${subjectId} (${subjectDisplayName})`)}  and lesson ${clc.blue(`${lessonId} (${lessonDisplayName})`)}`);            socket.emit('room_created', { roomCode });            addActivityLog({                logName: 'room_created',                logData: {                    roomCode,                    playerId: basicPlayerData.player_id,                    subjectId,                    lessonId                }            });            try {                await generateQuizAndAddItToRoom({ roomCode, selectedLessonSectionTitle });                let room = await getRoomByCode(roomCode);                if (!room || !room.room_active) {                    console.log(`${clc.bgWhite.black(roomCode)}: ${clc.red('Room not found or inactive after preparing quiz, player most likely closed quiz creation modal')}`);                } else {                    if (!room.room_data.quiz) {                        console.log(`${clc.bgWhite.black(roomCode)}: ${clc.red('Quiz did not get created succesfully. FORCE QUIT player ')}`);                        socket.emit('error_occurred', { errorCode: 'QUIZ_NOT_CREATED', message: `Quiz did not get created succesfully for room ${roomCode}.` });                        await handlePlayerQuitting({ io, roomCode, playerId: basicPlayerData?.player_id });                        return                    }                    console.log(`${clc.bgWhite.black(roomCode)}: Quiz is ready for players.`);                    socket.emit('quiz_prepared', { roomCode });                }            } catch (err) {                console.error(`${clc.bgWhite.black(roomCode)}: Error updating room with new quiz:`, err.message);                socket.emit('error_occurred', { errorCode: 'QUIZ_UPDATE_FAILED', message: `Failed to prepare quiz for room ${roomCode}.` });            }        });        socket.on('play_with_bot', async ({ roomCode }) => {            let room = await getRoomByCode(roomCode);            if (!room || !room.room_active) {                console.log(`${clc.bgWhite.black(roomCode)}: ${clc.red('Room not found or inactive.')}`);                socket.emit('error_occurred', { errorCode: 'ROOM_NOT_FOUND', message: `Room ${roomCode} does not exist or is not currently active.` });                return;            }            // Add bot player to the room            let botPlayerData = await getRandomBotUser();            console.log('got bot player : ' + botPlayerData?.player_email)            const existingBotIndex = room.room_data.playersData.findIndex(player => player.isBot);            let newPlayersData = [...room.room_data.playersData];            const botPlayer = { socketId: 'bot_socket', basicPlayerData: botPlayerData, xp: 0, isBot: true };            if (existingBotIndex !== -1) {                console.log(clc.red('Bot player already exists in the room which is WEIRD, replacing it.'))                newPlayersData[existingBotIndex] = botPlayer;            } else {                newPlayersData.push(botPlayer);            }            await updateRoom({                roomCode: roomCode,                path: "room_data.playersData",                newValue: newPlayersData            });            const playerIdsArray = room.room_data.playersData.map(player => player.basicPlayerData.player_id)            await updateRoom({                roomCode: roomCode,                path: "room_player_ids",                newValue: playerIdsArray            });            console.log(`${clc.bgWhite.black(roomCode)}: BOT player added to the room.`);            await startTimer({ io, roomCode });            await incrementPlayerQuizCounts({ playerIds: playerIdsArray, roomCode });              //update room_clash_started_at to current time              await updateRoom({                roomCode: roomCode,                path: "room_data.currentClashStartedAt",                newValue: new Date()            });            io.in(roomCode).emit('game_on', {                quiz: getQuizWithoutCorrectAnswers(room.room_data.quiz),                playersData: room.room_data.playersData,                timer: QUESTION_TIMER_DURATION,                roomCode            });            addActivityLog({                logName: 'bot_clash_started',                logData: {                    roomCode,                    playerIds: playerIdsArray                }            });            incrementLessonPlayCount(room.lesson_id);        });        socket.on('join_room', async ({ roomCode, basicPlayerData }) => {            let room = await getRoomByCode(roomCode);            if (!room || !room.room_active) {                console.log(`${clc.bgWhite.black(roomCode)}: ${clc.red('Room not found or inactive.')}`);                socket.emit('error_occurred', { errorCode: 'ROOM_NOT_FOUND', message: `Room ${roomCode} does not exist or is not currently active.` });                return            }            const playerAlreadyInRoom = room.room_data.playersData.some(player => player.basicPlayerData.player_id === basicPlayerData.player_id) && !room.room_player_ids.includes(basicPlayerData.player_id);            const roomHasMultiplePlayers = room.room_data.playersData.length > 1;            if (playerAlreadyInRoom && roomHasMultiplePlayers) {                await handlePlayerRejoin(io, socket, roomCode, { player_id: basicPlayerData.player_id, email: basicPlayerData.player_email });            } else {                console.log(`${clc.bgWhite.black(roomCode)}: Player ${clc.blue(basicPlayerData.player_email)} JOINED the room.`);                const newPlayersData = [                    ...room.room_data.playersData,                    { socketId: socket.id, basicPlayerData, xp: 0 }                ];                await updateRoom({                    roomCode: roomCode,                    path: "room_data.playersData",                    newValue: newPlayersData                });                const playerIdsArray = room.room_data.playersData.map(player => player.basicPlayerData.player_id)                console.log('playerIdsArray', playerIdsArray)                await updateRoom({                    roomCode: roomCode,                    path: "room_player_ids",                    newValue: playerIdsArray                });                socket.join(roomCode);                await startTimer({ io, roomCode });                await incrementPlayerQuizCounts({ playerIds: room.room_data.playersData.map(player => player.basicPlayerData.player_id), roomCode });                  //update room_clash_started_at to current time                  await updateRoom({                    roomCode: roomCode,                    path: "room_data.currentClashStartedAt",                    newValue: new Date()                });                io.in(roomCode).emit('game_on', {                    quiz: getQuizWithoutCorrectAnswers(room.room_data.quiz),                    playersData: room.room_data.playersData,                    timer: QUESTION_TIMER_DURATION,                    roomCode                });                addActivityLog({                    logName: 'clash_started',                    logData: {                        roomCode,                        playerIds: room.room_data.playersData.map(player => player.basicPlayerData.player_id),                        quizId: room.room_data.quiz_id,                    }                })                incrementLessonPlayCount(room.lesson_id);            }        });        socket.on('submit_answer', async ({ roomCode, answerIndex, playerId }) => {            console.log(`${clc.bgWhite.black(roomCode)}: Player ${clc.blue(playerId)} answered answer ${clc.green(answerIndex)}.`);            console.log(`${clc.bgWhite.black(roomCode)}: current question index: ${rooms[roomCode].room_data.currentQuestionIndex}`)            await checkIfAnswerIsCorrect({ io, roomCode, answerIndex, playerId });            io.in(roomCode).emit('player_answered', { playerId });            await moveToNextQuestionOrEndQuiz({ roomCode, io, answerIndex });        });        socket.on('send_message', ({ roomCode, message, playerId, stickyMessage }) => {            io.to(roomCode).emit('receive_message', { playerId, message, stickyMessage });        });        socket.on('request_replay', async ({ roomCode, playerId }) => {            const room = await getRoomByCode(roomCode);            if (!room || !room.room_active) {                console.log(`${clc.bgWhite.black(roomCode)}: ${clc.red('Room not found or inactive.')}`);                return socket.emit('error_occurred', { errorCode: 'ROOM_NOT_FOUND', message: `Room ${roomCode} does not exist.` });            }            if (room.room_data.playersData.some(player => player.isBot)) {                console.log(`${clc.bgWhite.black(roomCode)}: Replay initiated with bot.`);                await initializeRoom({ roomCode });                io.to(roomCode).emit('replay_accepted', { byPlayerId: playerId });                await generateQuizAndAddItToRoom({ roomCode, selectedLessonSectionTitle: "random" });                //update room_clash_started_at to current time                await updateRoom({                    roomCode: roomCode,                    path: "room_data.currentClashStartedAt",                    newValue: new Date()                });                io.in(roomCode).emit('game_on', { quiz: getQuizWithoutCorrectAnswers(room.room_data.quiz), playersData: room.room_data.playersData, timer: QUESTION_TIMER_DURATION });                await startTimer({ io, roomCode });                console.log(`${clc.bgWhite.black(roomCode)}: ${clc.yellow('REPLAY STARTED with new quiz and timer')}.`);                addActivityLog({                    logName: 'bot_clash_replayed',                    logData: {                        roomCode,                        playerIds: room.room_data.playersData.map(player => player.basicPlayerData.player_id),                        quizId: room.room_data.quiz_id,                    }                });            } else {                await updateRoom({                    roomCode: roomCode,                    path: "room_data.replayRequestedBy",                    newValue: playerId                });                console.log(`${clc.bgWhite.black(roomCode)}: ${clc.yellow('Replay requested by player')} ${clc.blue(playerId)}`);                io.to(roomCode).emit('replay_offered', { fromPlayerId: playerId });            }        });        // When a player accepts the replay request        socket.on('accept_replay', async ({ roomCode, playerId, selectedLessonSectionTitle }) => {            const room = await getRoomByCode(roomCode);            if (!room || !room.room_active) {                console.log(`${clc.bgWhite.black(roomCode)}: ${clc.red('Room not found for replay acceptance.')}`);                return socket.emit('error_occurred', { errorCode: 'ROOM_NOT_FOUND', message: `Room ${roomCode} does not exist.` });            }            if (room.room_data.replayRequestedBy && room.room_data.replayRequestedBy !== playerId) {                console.log(`${clc.bgWhite.black(roomCode)}: REPLAY ACCEPTED by player ${clc.blue(playerId)}. Initializing room for replay.`);                await initializeRoom({ roomCode });                io.to(roomCode).emit('replay_accepted', { byPlayerId: playerId });                await generateQuizAndAddItToRoom({ roomCode, selectedLessonSectionTitle });                if (!room.room_data.quiz) {                    console.log(`${clc.bgWhite.black(roomCode)}: ${clc.red('Quiz did not get created succesfully for replay acceptance. FORCE QUIT player ')}`);                    socket.emit('error_occurred', { errorCode: 'QUIZ_NOT_CREATED', message: `Quiz did not get created succesfully for room ${roomCode}.` });                    await handlePlayerQuitting({ io, roomCode, playerId });                    return                }                await incrementPlayerQuizCounts({ playerIds: room.room_data.playersData.map(player => player.basicPlayerData.player_id), roomCode });                await updateRoom({                    roomCode: roomCode,                    path: "room_data.currentClashStartedAt",                    newValue: new Date()                });                io.in(roomCode).emit('game_on', { quiz: getQuizWithoutCorrectAnswers(room.room_data.quiz), playersData: room.room_data.playersData, timer: QUESTION_TIMER_DURATION });                await startTimer({ io, roomCode });                console.log(`${clc.bgWhite.black(roomCode)}: ${clc.yellow('REPLAY STARTED with new quiz and timer')}.`);                await updateRoom({                    roomCode: roomCode,                    path: "room_data.replayRequestedBy",                    newValue: null                });                                addActivityLog({                    logName: 'clash_replayed',                    logData: {                        roomCode,                        playerIds: room.room_data.playersData.map(player => player.basicPlayerData.player_id),                        quizId: room.room_data.quiz_id,                    }                })                incrementLessonPlayCount(room.lesson_id);            } else {                console.log(`${clc.bgWhite.black(roomCode)}: ${clc.red('Invalid or unauthorized replay acceptance attempt by player')} ${clc.blue(playerId)}.`);            }        });        socket.on('abort_room_creation', async ({ roomCode, playerId }) => {            console.log(`${clc.bgWhite.black(roomCode)}: ${clc.yellow('ABORTING ROOM CREATION, deleting room, and closing socket connection.')}`);            const room = await getRoomByCode(roomCode);            if (!room) {                console.log(`${clc.bgWhite.black(roomCode)}: ${clc.red('Room not found for aborting creation.')}`);                return socket.emit('error_occurred', { errorCode: 'ROOM_NOT_FOUND', message: `Room ${roomCode} does not exist.` });            }            await updateRoom({ roomCode: roomCode, path: 'room_active', newValue: false });            delete rooms[roomCode];            socket.leave(roomCode); // Player is leaving the room            console.log(`${clc.bgWhite.black(roomCode)}: ${clc.green('Room set to INACTIVE, DELETED from memory, and socket connection closed successfully.')}`);        });        socket.on('rejoin_room', async ({ playerId, roomCode }) => {            // Logic to validate and find the room and player            let room = await getRoomByCode(roomCode);            if (!room || !room.room_active) {                console.log(`${clc.bgWhite.black(roomCode)}: ${clc.red('attempting to REJOIN room, Room NOT FOUND or INACTIVE.')}`);                return; // Handle this scenario appropriately            }            // Check if player has already joined using their socket id to prevent rejoining            const playerAlreadyJoined = room.room_data.playersData.some(player => player.socketId === socket.id && !player.isQuit);            if (playerAlreadyJoined) {                console.log(`${clc.bgWhite.black(roomCode)}: Player ${playerId} already in room, no need to rejoin.`);                return;            }            await handlePlayerRejoin(io, socket, roomCode, { player_id: playerId });            // Use playerId to associate the socket with the player        });        socket.on('quit_room', async ({ roomCode, playerId }) => {            console.log(`${clc.bgWhite.black(roomCode)}: ${clc.yellow(`Player ${clc.blue(playerId)} requested to QUIT.`)}`);            const room = await getRoomByCode(roomCode);            if (!room || !room.room_active) {                return socket.emit('error_occurred', { errorCode: 'ROOM_NOT_FOUND', message: `Room ${roomCode} does not exist or is not active.` });            }            await handlePlayerQuitting({ io, roomCode, playerId });        });        socket.on('disconnect', async () => {            for (const [roomCode, room] of Object.entries(rooms)) {                const quittingPlayer = room.room_data.playersData.find(player => player.socketId === socket.id && !player.isQuit);                if (quittingPlayer) {                    console.log(`${clc.yellow('Player DISCONNECTED')}`);                    await handlePlayerQuitting({ io, roomCode: room.room_code, playerId: quittingPlayer.basicPlayerData.player_id });                    break; // Exit loop after handling the quitting player                }            }        });    });}module.exports = quizRoomManager; ---File: rollback.sh --- #!/bin/bash#./rollback.sh <commit-hash> (optional commit hash, otherwise rollback to the previous commit)# SSH to server and start rollback processSSH_HOST="root@104.248.142.129"SSH_DIR="~/class-clash-backend"# Check if a commit hash is provided as an argumentif [ "$#" -eq 1 ]; then    COMMIT_HASH=$1    echo -e "\n\033[34mInitiating ROLLBACK to commit: $COMMIT_HASH...\033[0m\n"else    echo -e "\n\033[34mInitiating ROLLBACK to undo the latest changes...\033[0m\n"    # Get the hash of the commit that is going to be undone    COMMIT_HASH=$(ssh $SSH_HOST "cd $SSH_DIR && git rev-parse HEAD")    echo -e "\n\033[34mCommit to undo: $COMMIT_HASH\033[0m\n"fi# Conditionally reset to a specific commit if provided, else undo the latest commitif [ "$#" -eq 1 ]; then    ssh $SSH_HOST "cd $SSH_DIR && git reset --hard $COMMIT_HASH && git push origin prod --force" || {      echo -e "\n\033[31mRollback failed during git reset to $COMMIT_HASH. Please check manually.\033[0m\n"      exit 1    }else    ssh $SSH_HOST "cd $SSH_DIR && git reset --hard HEAD~1 && git push origin prod --force" || {      echo -e "\n\033[31mRollback failed during git reset. Please check manually.\033[0m\n"      exit 1    }fiecho -e "\n\033[34mInstalling dependencies for the current commit...\033[0m\n"# Run npm install to ensure dependencies match the current statessh $SSH_HOST "cd $SSH_DIR && npm install" || {  echo -e "\n\033[31mRollback failed during npm install. Please check manually.\033[0m\n"  exit 1}echo -e "\n\033[34mReloading PM2 process to reflect changes...\033[0m\n"# Reload PM2 to apply the changes from the rollbackssh $SSH_HOST "cd $SSH_DIR && pm2 reload server || pm2 start server.js --name server" || {  echo -e "\n\033[31mRollback failed during PM2 reload/start. Please check manually.\033[0m\n"  exit 1}if [ "$#" -eq 1 ]; then    echo -e "\n\033[32mRollback completed. The production environment has been reverted to the commit: $COMMIT_HASH\033[0m\n"else    echo -e "\n\033[32mRollback completed. The production environment has been reverted to the state before the latest commit: $COMMIT_HASH\033[0m\n"fi ---Directory: routesFile: analytics.js --- var express = require('express');var router = express.Router();const db = require('../db/db');const clc = require('cli-color');// Helper function to calculate date rangesfunction getDateRange(timeframe) {    switch (timeframe) {        case 'today':            return [                db.raw('CURRENT_DATE'),                db.raw('CURRENT_DATE + INTERVAL \'1 day\' - INTERVAL \'1 second\'')            ];        case 'yesterday':            return [                db.raw('CURRENT_DATE - INTERVAL \'1 day\''),                db.raw('CURRENT_DATE - INTERVAL \'1 second\'')            ];        case 'last_7_days':            return [                db.raw('CURRENT_DATE - INTERVAL \'7 days\''),                db.raw('CURRENT_DATE')            ];        case 'last_30_days':            return [                db.raw('CURRENT_DATE - INTERVAL \'30 days\''),                db.raw('CURRENT_DATE')            ];            case 'this_week':                return [                    db.raw('DATE_TRUNC(\'week\', CURRENT_DATE)'),                    db.raw('CURRENT_DATE + INTERVAL \'1 day\' - INTERVAL \'1 second\'')                ];                    case 'last_week':            return [                db.raw('DATE_TRUNC(\'week\', CURRENT_DATE) - INTERVAL \'1 week\''),                db.raw('DATE_TRUNC(\'week\', CURRENT_DATE) - INTERVAL \'1 second\'')            ];            case 'this_month':                return [                    db.raw('DATE_TRUNC(\'month\', CURRENT_DATE)'),                    db.raw('CURRENT_DATE + INTERVAL \'1 day\' - INTERVAL \'1 second\'')                ];                    case 'last_month':            return [                db.raw('DATE_TRUNC(\'month\', CURRENT_DATE - INTERVAL \'1 month\')'),                db.raw('DATE_TRUNC(\'month\', CURRENT_DATE) - INTERVAL \'1 second\'')            ];        default:            return [null, null]; // No date filter for 'alltime'    }}// Function to get total events within a timeframeasync function getTotalEvents(eventName, timeframe) {    const query = db('activity_log').where('activity_log_name', eventName);    const [startDate, endDate] = getDateRange(timeframe);    if (startDate && endDate) {        query.whereBetween('activity_log_timestamp', [startDate, endDate]);    }    const result = await query.count('activity_log_id as total');    return result[0].total;}// Function to get time series data for events within a timeframeasync function getTimeSeriesData(eventName, timeframe) {    const [startDate, endDate] = getDateRange(timeframe);    if (timeframe === 'alltime') {        let rawQuery = `            SELECT DATE(activity_log_timestamp) as timestamp,                   COUNT(activity_log_id) as count            FROM activity_log            WHERE activity_log_name = ?            GROUP BY DATE(activity_log_timestamp)            ORDER BY DATE(activity_log_timestamp)        `;        return await db.raw(rawQuery, [eventName])            .then(results => {                return results.rows.map(row => ({                    date: row.timestamp,                    count: parseInt(row.count)                }));            });    } else {        let dateGroup = 'DATE(activity_log_timestamp)';        if (timeframe === 'today' || timeframe === 'yesterday') {            dateGroup = 'EXTRACT(HOUR FROM activity_log_timestamp)'; // Group by the hour            let rawQuery = `                WITH hourly_series AS (                    SELECT generate_series(${startDate}, ${endDate}, '1 hour'::interval) AS timestamp                )                SELECT hs.timestamp, COALESCE(COUNT(al.activity_log_id), 0) as count                FROM hourly_series hs                LEFT JOIN activity_log al                ON EXTRACT(HOUR FROM al.activity_log_timestamp) = EXTRACT(HOUR FROM hs.timestamp)                AND al.activity_log_name = ?                AND DATE(al.activity_log_timestamp) = DATE(hs.timestamp)                GROUP BY hs.timestamp                ORDER BY hs.timestamp            `;            return await db.raw(rawQuery, [eventName])                .then(results => {                    return results.rows.map(row => ({                        date: row.timestamp,                        count: parseInt(row.count)                    }));                });        } else {            let rawQuery = `                WITH date_series AS (                    SELECT generate_series(${startDate}, ${endDate}, '1 day'::interval) AS timestamp                )                SELECT ds.timestamp, COALESCE(COUNT(al.activity_log_id), 0) as count                FROM date_series ds                LEFT JOIN activity_log al                ON DATE(al.activity_log_timestamp) = ds.timestamp AND al.activity_log_name = ?                GROUP BY ds.timestamp                ORDER BY ds.timestamp            `;            return await db.raw(rawQuery, [eventName])                .then(results => {                    return results.rows.map(row => ({                        date: row.timestamp,                        count: parseInt(row.count)                    }));                });        }    }}// Endpoint for each event type with timeframe supportconst eventNames = [    'player_joined',    'room_created',    'clash_started',    'bot_clash_started',    'clash_replayed',    'suggestion_received',    'bot_clash_replayed'];eventNames.forEach(eventName => {    router.get(`/${eventName.replace(/_/g, '-')}/:timeframe?`, async (req, res) => {        const { timeframe } = req.params;        try {            const total = await getTotalEvents(eventName, timeframe || 'alltime');            const timeSeries = await getTimeSeriesData(eventName, timeframe || 'alltime');            res.json({                [`total${eventName.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('')}`]: total,                timeSeriesData: timeSeries            });        } catch ( error) {            console.error(clc.red(`Error fetching data for ${eventName}:`, error));            res.status(500).send(`Error fetching data for ${eventName}`);        }    });});router.get('/clash-quiz-completion-average/:timeframe?', async (req, res) => {    const { timeframe } = req.params;    try {        const dateRanges = getDateRange(timeframe || 'alltime');        const [startDate, endDate] = dateRanges;        const query = `            SELECT AVG(clash_quiz_completion_percentage) as average_completion            FROM clash            ${startDate && endDate ? `WHERE clash_timestamp BETWEEN ${startDate} AND ${endDate}` : ''}        `;        const result = await db.raw(query);        const averageCompletion = result.rows[0].average_completion;        res.json({            timeframe: timeframe || 'alltime',            averageCompletion: averageCompletion ? parseFloat(averageCompletion).toFixed(2) : 0        });    } catch (error) {        console.error(clc.red(`Error fetching average completion for timeframe ${timeframe}:`, error));        res.status(500).send(`Error fetching average completion for timeframe ${timeframe}`);    }});module.exports = router; ---File: grade.js --- var express = require('express');var router = express.Router();const db = require('../db/db');const clc = require('cli-color');//get all grades endpoint router.get('/', async (req, res) => {    try {        const query = `            SELECT * FROM grade WHERE grade_hidden = false;        `;        const result = await db.raw(query);        res.json(result.rows);    } catch (err) {        console.error(clc.red(`Error getting all grades: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});//get grade by id endpointrouter.get('/id/:id', async (req, res) => {    try {        const { id } = req.params;        const query = `            SELECT * FROM grade WHERE grade_id = ?;        `;        const result = await db.raw(query, [id]);        if (result.rows.length === 0) {            res.status(404).json({ message: 'Grade not found' });        } else {            res.json(result.rows[0]);        }    } catch (err) {        console.error(clc.red(`Error getting grade by ID: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});router.post('/', async (req, res) => {    try {        const { grade_display_name } = req.body;        if (!grade_display_name) {            return res.status(400).json({ message: 'Grade name is required' });        }        const query = `            INSERT INTO grade(grade_display_name)            VALUES(?)            RETURNING *;        `;        const result = await db.raw(query, [grade_display_name]);        res.status(201).json(result.rows[0]);    } catch (err) {        console.error(clc.red(`Error adding new grade: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});router.put('/:id', async (req, res) => {    try {        const { id } = req.params;        const { grade_display_name } = req.body;        if (!grade_display_name) {            return res.status(400).json({ message: 'Grade name is required' });        }        const query = `            UPDATE grade            SET grade_display_name = ?            WHERE grade_id = ?            RETURNING *;        `;        const result = await db.raw(query, [grade_display_name, id]);        if (result.rows.length === 0) {            res.status(404).json({ message: 'Grade not found' });        } else {            res.json(result.rows[0]);        }    } catch (err) {        console.error(clc.red(`Error updating grade: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});module.exports = router; ---File: lesson.js --- var express = require('express');var router = express.Router();const db = require('../db/db');const clc = require('cli-color');const splitLessonContentIntoSections = require('../utilities/splitLessonContentIntoSections');//get lesson based on the provided subject_id and optionally include lesson_content if includeContent is truerouter.get('/subject/:subject_id', async (req, res) => {    try {        const { subject_id } = req.params;        const includeContent = req.query.includeContent === 'true';        let query = `            SELECT lesson_id, subject_id, lesson_display_name, lesson_display_image, lesson_timestamp        `;        if (includeContent) {            query += `, lesson_content `;        }        query += `FROM lesson WHERE subject_id = ? ORDER BY lesson_timestamp;`;        const result = await db.raw(query, [subject_id]);        res.json(result.rows);    } catch (err) {        console.error(clc.red(`Error getting lesson by subject_id: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});router.get('/grade/:grade_id', async (req, res) => {    try {      const { grade_id } = req.params;        const query = `        SELECT           lesson.lesson_id,           lesson.subject_id,           lesson.lesson_display_name,           lesson.lesson_display_image,          lesson.lesson_sections,            lesson.lesson_timestamp        FROM subject         JOIN lesson ON subject.subject_id = lesson.subject_id        WHERE subject.grade_id = ?        ORDER BY lesson.lesson_play_count DESC;      `;      const result = await db.raw(query, [grade_id]);      // Process the result to remove sectionContent from lesson_sections      const processedLessons = result.rows.map(lesson => {        if (lesson.lesson_sections && lesson.lesson_sections.sections) {          lesson.lesson_sections.sections = lesson.lesson_sections.sections.map(section => {            return { sectionTitle: section.sectionTitle };          });        }        return lesson;      });      res.json(processedLessons);       } catch (err) {      console.error(clc.red(`Error getting lesson by grade_id: ${err.message}`));      res.status(500).json({ message: 'Internal Server Error' });    }  });//get lesson by id endpointrouter.get('/id/:id', async (req, res) => {    try {        const { id } = req.params;        const query = `            SELECT * FROM lesson WHERE lesson_id = ?;        `;        const result = await db.raw(query, [id]);        if (result.rows.length === 0) {            res.status(404).json({ message: 'Lesson not found' });        } else {            res.json(result.rows[0]);        }    } catch (err) {        console.error(clc.red(`Error getting lesson by ID: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});router.post('/', async (req, res) => {    try {        const { lesson_display_name, lesson_content, lesson_display_image, subject_id } = req.body;        const lessonSections = await splitLessonContentIntoSections(lesson_content);                if (!lesson_display_name || !lesson_content || !subject_id) {            return res.status(400).json({ message: 'Lesson display name, content, and subject ID are required' });        }        const query = `            INSERT INTO lesson(lesson_display_name, lesson_content, lesson_sections, lesson_display_image, subject_id)            VALUES(?, ?, ?, ?, ?)            RETURNING *;        `;        const result = await db.raw(query, [lesson_display_name, lesson_content, JSON.stringify(lessonSections), lesson_display_image, subject_id]);        res.status(201).json(result.rows[0]);    } catch (err) {        console.error(clc.red(`Error adding new lesson: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});router.put('/:id', async (req, res) => {    try {        const { id } = req.params;        const { lesson_display_name, lesson_content, lesson_display_image } = req.body;        if (!lesson_display_name || !lesson_content) {            return res.status(400).json({ message: 'Lesson display name and content are required' });        }        // First, get the current lesson content to check if it has changed        const currentLesson = await db('lesson').where({ lesson_id: id }).select('lesson_content');        if (currentLesson.length === 0) {            return res.status(404).json({ message: 'Lesson not found' });        }        let lessonSections;        // If the lesson content has changed, split it into sections        if (currentLesson[0].lesson_content !== lesson_content) {            lessonSections = await splitLessonContentIntoSections(lesson_content);        }        // Prepare the query to update the lesson, including lesson_sections if it has changed        const updateFields = {            lesson_display_name,            lesson_content,            lesson_display_image,        };        if (lessonSections) {            updateFields.lesson_sections = lessonSections;        }        const result = await db('lesson')            .where({ lesson_id: id })            .update(updateFields, ['*']);        if (result.length === 0) {            res.status(404).json({ message: 'Lesson not found' });        } else {            res.json(result[0]);        }    } catch (err) {        console.error(clc.red(`Error updating lesson: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});router.delete('/:id', async (req, res) => {    const { id } = req.params;    try {        // Start transaction        await db.transaction(async trx => {            // Delete quizzes from clash table that are associated with the lesson            const quizzes = await trx('quiz').where({ lesson_id: id }).select('quiz_id');            const quizIds = quizzes.map(quiz => quiz.quiz_id);            if (quizIds.length > 0) {                await trx('clash').whereIn('quiz_id', quizIds).del();            }            // Delete quizzes from quiz table that are associated with the lesson            await trx('quiz').where({ lesson_id: id }).del();            // Delete rooms from room table that are associated with the lesson            await trx('room').where({ lesson_id: id }).del();            // Finally, delete the lesson itself            const deletedLesson = await trx('lesson').where({ lesson_id: id }).del();            if (deletedLesson) {                res.status(200).json({ message: 'Lesson and all associated quizzes and rooms successfully deleted' });            } else {                res.status(404).json({ message: 'Lesson not found' });            }        });    } catch (err) {        console.error(clc.red(`Error deleting lesson: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});module.exports = router; ---File: player.js --- var express = require('express');var router = express.Router();const db = require('../db/db');const clc = require('cli-color');const addActivityLog = require('../utilities/addActivityLog');const sendFacebookRegistrationEvent = require('../utilities/sendFacebookRegistrationEvent');var admin = require("firebase-admin");var serviceAccount = require("../firebase-admin-config.json");admin.initializeApp({  credential: admin.credential.cert(serviceAccount)});router.get('/uid/:uid', async (req, res) => {    try {        const { uid } = req.params;        // Modified query to use LEFT JOIN to include players without a grade        const query = `            SELECT player.*, grade.*            FROM player            LEFT JOIN grade ON player.grade_id = grade.grade_id            WHERE player.player_uid = ?;        `;        const playerData = await db.raw(query, [uid]);        if (playerData.rows && playerData.rows.length > 0) {            let player = playerData.rows[0]; // Assuming you only expect one result for a given UID            // Check if player_profile_picture_url is empty and replace it if necessary            if (!player.player_profile_picture_url || player.player_profile_picture_url.trim() === '') {                player.player_profile_picture_url = `https://api.dicebear.com/8.x/initials/svg?seed=${player.player_first_name}&&backgroundType=gradientLinear,solid`;            }            // The query response includes player data with or without grade information            res.json({                success: true,                player: player,            });        } else {            res.status(404).json({                success: false,                message: 'Player not found',            });        }    } catch (err) {        console.error('Error retrieving player data: ' + err.message);        res.status(500).json({ error: true, message: err.message });    }});router.post('/new', async (req, res) => {    var addedPlayerToFirebase = false;let  player_uid;     try {        console.log(req.body);        const {            player_first_name,            player_last_name,            player_email,            player_password,            player_country,            grade_id         } = req.body;        // Create a new user in Firebase        const newUser = await admin.auth().createUser({            email: player_email,            emailVerified: false,            password: player_password,            displayName: `${player_first_name} ${player_last_name}`,        });        addedPlayerToFirebase = true;        // Get the user's UID from the newUser object         player_uid = newUser.uid;        // Insert new player into the database using raw SQL        // Include grade_id in the insert statement        const insertQuery = `            INSERT INTO player (                player_uid,                player_email,                player_first_name,                player_last_name,                player_country,                grade_id,                player_total_xp,                player_created_on                            ) VALUES (?, ?, ?, ?, ?, ?, 100, CURRENT_TIMESTAMP) RETURNING *;        `;        // Include grade_id in the parameters for the query        // If grade_id is optional and can be null, ensure the front end sends null for users without a grade        const newPlayer = await db.raw(insertQuery, [            player_uid,            player_email,            player_first_name,            player_last_name,            player_country,            grade_id // Pass grade_id to the query        ]);        console.log('New player added!');        // Log the player_joined activity        await addActivityLog({            logName: 'player_joined',            logData: {                player_uid            }        });        let current_timestamp = Math.floor(new Date() / 1000);        if (process.env.NODE_ENV !== 'development') {            sendFacebookRegistrationEvent({                email: player_email,                first_name: player_first_name,                last_name: player_last_name,                user_id: player_uid,                ip_adresse: req.ip,                user_agent: req.headers['user-agent'],                current_timestamp: current_timestamp,                eventID: player_uid            });        }          res.json({            player: newPlayer.rows[0] // Accessing the first row of the result        });    } catch (err) {        console.error('Error adding player: ' + err.message);           // If player was added to Firebase but an error occurred afterwards           if (addedPlayerToFirebase && player_uid) {            try {                // Attempt to delete the user from Firebase to maintain consistency                await admin.auth().deleteUser(player_uid);                console.log(`Deleted player ${player_uid} from Firebase due to error.`);            } catch (firebaseErr) {                console.error(`Failed to delete player ${player_uid} from Firebase: ${firebaseErr.message}`);                // Consider whether you need to inform the client of this failure                // For simplicity, this example does not send a different response in this scenario            }        }        res.status(500).json({ error: true, message: err.message });    }});router.put('/update/:uid', async (req, res) => {    try {        const { uid } = req.params;        const {            player_first_name,            player_last_name,            player_email,            player_country,            grade_id        } = req.body;        // Construct update query dynamically based on provided fields        let updateFields = [];        let queryParams = [];        if (player_first_name !== undefined) {            updateFields.push(`player_first_name = ?`);            queryParams.push(player_first_name);        }        if (player_last_name !== undefined) {            updateFields.push(`player_last_name = ?`);            queryParams.push(player_last_name);        }        if (player_email !== undefined) {            updateFields.push(`player_email = ?`);            queryParams.push(player_email);        }        if (player_country !== undefined) {            updateFields.push(`player_country = ?`);            queryParams.push(player_country);        }        if (grade_id !== undefined) {            updateFields.push(`grade_id = ?`);            queryParams.push(grade_id);        }        queryParams.push(uid); // For WHERE condition        const query = `            UPDATE player            SET ${updateFields.join(', ')}            WHERE player_uid = ?            RETURNING *;        `;        const result = await db.raw(query, queryParams);        if (result.rows && result.rows.length > 0) {            res.json({                success: true,                updatedPlayer: result.rows[0],            });        } else {            res.status(404).json({                success: false,                message: 'Player not found',            });        }    } catch (err) {        console.error('Error updating player: ' + err.message);        res.status(500).json({ error: true, message: err.message });    }});module.exports = router; ---File: room.js --- var express = require('express');var router = express.Router();const db = require('../db/db');const clc = require('cli-color');router.post('/isValid', async (req, res) => {    const { room_code } = req.body;    try {        const room = await db('room').where({ room_code: room_code }).first();        if (!room) {            return res.status(404).json({ message: 'Room not found' });        }        if (!room.room_active) {            return res.status(400).json({ message: 'Room is not active' });        }        if (room.room_player_ids && room.room_player_ids.length > 1) {            return res.status(400).json({ message: 'Room is already filled' });        }        res.json({ message: 'Room is valid', room: room });    } catch (err) {        console.error(clc.red(`Error checking room validity: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});module.exports = router; ---File: subject.js --- var express = require('express');var router = express.Router();const db = require('../db/db');const clc = require('cli-color');//get subject based on the given grade_id router.get('/grade/:grade_id', async (req, res) => {    try {        const { grade_id } = req.params;        const query = `            SELECT * FROM subject WHERE grade_id = ? AND subject_hidden = FALSE;        `;        const result = await db.raw(query, [grade_id]);        res.json(result.rows);    } catch (err) {        console.error(clc.red(`Error getting subject by grade_id: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});//get subject by id endpointrouter.get('/id/:id', async (req, res) => {    try {        const { id } = req.params;        const query = `            SELECT * FROM subject WHERE subject_id = ?;        `;        const result = await db.raw(query, [id]);        if (result.rows.length === 0) {            res.status(404).json({ message: 'Subject not found' });        } else {            res.json(result.rows[0]);        }    } catch (err) {        console.error(clc.red(`Error getting subject by ID: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});router.post('/', async (req, res) => {    try {        const { subject_display_name, grade_id, subject_display_image } = req.body;                if (!subject_display_name || !grade_id || !subject_display_image) {            return res.status(400).json({ message: 'Subject name, grade ID, and subject image are required' });        }        const query = `            INSERT INTO subject(subject_display_name, grade_id, subject_display_image)            VALUES(?, ?, ?)            RETURNING *;        `;        const result = await db.raw(query, [subject_display_name, grade_id, subject_display_image]);        res.status(201).json(result.rows[0]);    } catch (err) {        console.error(clc.red(`Error adding new subject: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});router.put('/:id', async (req, res) => {    try {        const { id } = req.params;        const { subject_display_name } = req.body;        if (!subject_display_name) {            return res.status(400).json({ message: 'Subject name is required' });        }        const updateQuery = `            UPDATE subject            SET subject_display_name = ?            WHERE subject_id = ?;        `;        const result = await db.raw(updateQuery, [subject_display_name, id]);        if (result.rowCount === 0) {            res.status(404).json({ message: 'Subject not found' });        } else {            res.json({ message: 'Subject updated successfully' });        }    } catch (err) {        console.error(clc.red(`Error updating subject: ${err.message}`));        res.status(500).json({ message: 'Internal Server Error' });    }});module.exports = router; ---File: scheduledJobs.js --- const cron = require('node-cron');const resetAllPlayersDailyQuizCount = require('./utilities/resetAllPlayersDailyQuizCount');function initializeScheduledJobs() {    if (process.env.NODE_ENV == 'test') {        return;    }    // Schedule the resetAllPlayersDailyQuizCount to run at midnight every day    cron.schedule('0 0 * * *', async () => {        console.log('Resetting all players’ daily quiz count...');        await resetAllPlayersDailyQuizCount();        console.log('Reset completed.');    }, {        scheduled: true,        timezone: "UTC"    });}module.exports = initializeScheduledJobs; ---Directory: scriptsDirectory: reusable_scriptsFile: addNewGrade.js --- const db = require('../../db/db');const addNewGrade = async (gradeKeyName, gradeDisplayName) => {    try {        const query = `            INSERT INTO grade(grade_key_name, grade_display_name)            VALUES(?, ?)            RETURNING grade_id;`; // Returns the ID of the newly inserted grade        const result = await db.raw(query, [gradeKeyName, gradeDisplayName]);        const newGradeId = result.rows[0].grade_id;        console.log(`Added new grade. ID: ${newGradeId}`);        return newGradeId;    } catch (err) {        console.error(`Error adding new grade:`, err.message);    }};//test it addNewGrade('secondary_school_1', 'السنة الأولى ثانوي'); ---File: addNewLesson.js --- const db  = require('../../db/db');const addNewLesson = async (subjectKeyName, lessonKeyName, lessonDisplayName, lessonContent) => {    try {        // First, find the subject_id using the subject_key_name        const subjectQuery = `SELECT subject_id FROM subject WHERE subject_key_name = ?`;        const subjectResult = await db.raw(subjectQuery, [subjectKeyName]);        if (subjectResult.rows.length === 0) {            console.error(`Subject with key name "${subjectKeyName}" not found.`);            return;        }        const subjectId = subjectResult.rows[0].subject_id;        // Then, insert the new lesson using the found subject_id        const lessonQuery = `            INSERT INTO lesson(subject_id, lesson_key_name, lesson_display_name, lesson_content)            VALUES(?, ?, ?, ?)            RETURNING lesson_id;`;        const lessonResult = await db.raw(lessonQuery, [subjectId, lessonKeyName, lessonDisplayName, lessonContent]);        const newLessonId = lessonResult.rows[0].lesson_id;        console.log(`Added new lesson with ID: ${newLessonId} to subject ${subjectKeyName}`);        return newLessonId;    } catch (err) {        console.error(`Error adding new lesson:`, err.message);    }};//add bnew lesson to history subjectaddNewLesson('history_middle_school_8', 'tawhid_biled_maghreb_andalus', 'محاولات توحيد بلاد المغرب والأندلس', `* إثر سقوط دولة الأمويين بالأندلس سنة 422هـ/1031م وانتقال الخلافة الفاطميّة إلى القاهرة سنة 362هـ/973م دخلت منطقة المغرب الإسلامي مرحلة من التفكّك السياسي ممّا جعلها محلّ أطماع القوى الخارجيّة. دفع هذا الوضع إلى بروز حركات إصلاح ديني وسياسي قادها المرابطون ثم الموحّدون.* ظهرت دعوة المرابطين بين بربر لمتونة من قبيلة صنهاجة بالجنوب الغربي للمغرب الأقصى على يد عبد الله بن ياسين الجزولي.* تمكّنت حركة المرابطين من إقامة دولة عُرفت بتمسّكها بمذهب مالك واعتبرت ما سوى ذلك بدعا عملت على محاربتها.* يعتبر يوسف بن تاشفين المؤسّس الحقيقي لدولة المرابطين، أسّس مدينة مراكش واتّخذها عاصمة له سنة 445هـ/1062م.* نجح المرابطون في إيقاف حركة الاسترداد التي قادها الإسبان انطلاقا من شمال إسبانيا وأصبحت تهدّد الوجود الإسلامي وذلك بانتصارهم الساحق في معركة الزلاقة الشهيرة سنة 479هـ/1086م كما نجحوا في مدّ نفوذهم في اتجاه الشرق إلى حدود مدينة بجاية فتمكنّوا بذلك من توحيد الجزء الأكبر من الغرب الإسلامي في دولة واحدة امتدت من بلاد السودان جنوبا إلى الأندلس شمالا إلى حدود افريقية شرقا.* منذ عهد الأمير المرابطي علي بن يوسف بن تاشفين (500-537هـ) دخلت دولة المرابطين مرحلة من الضعف بسبب تنامي نفوذ الفقهاء المالكين وتدخلهم في الشؤون السياسيّة.* استغلّ الموحّدون ضعف دولة المرابطين لبثّ دعوتهم انطلاقا من جنوب المغرب الأقصى ومن مدينة تينملل تحديدا بقيادة محمد بن تومرت الذي أقام دعوته على مبدأ التوحيد واعتبر نفسه المهدي المنتظر الذي سيملأ الأرض عدلا بعد أن ملأت جورا.* يعتبر عبد المؤمن بن علي وهو أحد تلاميذ المهدي وأتباعه المؤسّس الحقيقي لدولة الموحّدين سنة 541هـ/1147م. استطاعت بسط نفوذها على الأندلس وإيقاف التقدّم الإسباني في معركة الأرك (591هـ) التي مكّنت من تأجيل سقوط الأندلس لمدّة تزيد عن القرنين من الزمن.* مكّن توسيع الموحّدين نحو الشرق من توحيد كامل بلاد المغرب عندما تمكّن عبد المؤمن بن علي من السيطرة على افريقيّة وفتح المهدية سنة 555هـ وإجلاء النورمان عنها وعن بقيّة المدن الإفريقيّة وبذلك تجاوزت دولة الموحّدين ما أنجزه المرابطون من حيث الامتداد المجالي لدولتهم.* أدّت الوحدة السياسيّة للغرب الإسلامي في عصر الموحّدين خاصة، إلى تلاقح الثقافتين المغربية والأندلسيّة وإلى تمازج بشري واجتماعي جعل من المنطقة كيانا متميّزا في إطار الفضاء الحضاري الإسلامي. `) ---File: addNewSubject.js --- const db = require('../../db/db');const addNewSubject = async (gradeKeyName, subjectKeyName, subjectDisplayName) => {    try {        // First, find the grade_id using the grade_key_name        const gradeQuery = `SELECT grade_id FROM grade WHERE grade_key_name = ?`;        const gradeResult = await db.raw(gradeQuery, [gradeKeyName]);        if (gradeResult.rows.length === 0) {            console.error(`Grade with key name "${gradeKeyName}" not found.`);            return;        }        const gradeId = gradeResult.rows[0].grade_id;        // Then, insert the new subject using the found grade_id        const subjectQuery = `            INSERT INTO subject(grade_id, subject_key_name, subject_display_name)            VALUES(?, ?, ?)            RETURNING subject_id;`;        const subjectResult = await db.raw(subjectQuery, [gradeId, subjectKeyName, subjectDisplayName]);        const newSubjectId = subjectResult.rows[0].subject_id;        console.log(`Added new subject with ID: ${newSubjectId} to grade ${gradeKeyName}`);        return newSubjectId;    } catch (err) {        console.error(`Error adding new subject:`, err.message);    }};//add history subject to middle school_8addNewSubject('middle_school_8', 'history', 'التاريخ'); ---File: runResetAllPlayersDailyQuizCount.js --- const resetAllPlayersDailyQuizCount = require('../../utilities/resetAllPlayersDailyQuizCount');const runResetAllPlayersDailyQuizCount = async () => {    try {        const result = await resetAllPlayersDailyQuizCount();    } catch (err) {        console.error(`Error resetting daily quiz count:`, err.message);    }}   runResetAllPlayersDailyQuizCount(); ---File: server.js --- const appRoot = require('app-root-path');require('dotenv').config({ path: `${appRoot}/.env` });const getAndSplitAllLessonsIntoSections = require('./utilities/getAndSplitAllLessonsIntoSections');const player = require('./routes/player');const grade = require('./routes/grade');const subject = require('./routes/subject');const lesson = require('./routes/lesson');const room = require('./routes/room');const analytics = require('./routes/analytics');const clc = require('cli-color');const express = require('express');const cors = require('cors');const app = express();const server = require('http').createServer(app);const quizRoomManager = require('./quizRoomManager'); // Adjust the path as necessaryconst initializeScheduledJobs = require('./scheduledJobs');const addActivityLog = require('./utilities/addActivityLog');const sendEmail = require('./utilities/SendEmail');app.use(cors({ allow: '*' }));app.use(express.json());app.use('/api/player', player);app.use('/api/grade', grade);app.use('/api/subject', subject);app.use('/api/lesson', lesson);app.use('/api/room', room);app.use('/api/analytics', analytics);app.post('/api/suggestion', async (req, res) => {    const { suggestion, playerData } = req.body;    try {        console.log(clc.green('Suggestion received:', suggestion));        await sendEmail({            to: 'aladynjr@gmail.com',            subject: `New Suggestion Received from ${playerData?.player_email}`,            html: `<p>${suggestion}</p>`,        });        addActivityLog({ logName: 'suggestion_received', logData: { suggestion, playerId: playerData?.player_id } });        res.status(200).send({ message: 'Suggestion sent successfully' });    } catch (error) {        console.error('Failed to send suggestion:', error);        res.status(500).send({ message: 'Failed to send suggestion' });    }});quizRoomManager(server);initializeScheduledJobs();if (process.env.NODE_ENV !== 'test') {    server.listen(8080, async () => {        await getAndSplitAllLessonsIntoSections();        console.log(clc.blue(`Listening on port 8080...`));    });}app.get('/', (req, res) => {    res.json({ message: 'yolo' });});module.exports = server; ---Directory: testsFile: createRoom.test.js --- const appRoot = require('app-root-path');require('dotenv').config({ path: `${appRoot}/.env` });const io = require('socket.io-client');const server = require('../server'); // Adjust the path as neededdescribe('Room Creation and Quiz Preparation via Socket.IO', () => {  let clientSocket;  beforeAll((done) => {    server.listen(8080); // Ensure this matches your testing environment    clientSocket = io.connect('http://localhost:8080', {      'force new connection': true,      transports: ['websocket'],    });    clientSocket.on('connect', done);    global.console = { log: jest.fn() };  });  afterAll((done) => {    clientSocket.close();    server.close(() => done()); // Only call done() after the server has closed  });  it('should create a room and receive quiz prepared event', (done) => {    const roomDetails = {      subjectId: '1',      lessonId: '1',      lessonDisplayName: 'Introduction to Algebra',      subjectDisplayName: 'Mathematics',      basicPlayerData: {        player_email: 'test@example.com',        grade_id: 'grade5',        grade_display_name: 'Grade 5'      }    };    clientSocket.emit('create_room', roomDetails);     clientSocket.on('room_created', (data) => {      expect(data).toHaveProperty('roomCode');      console.log(`Room created with code: ${data.roomCode}`);    });    clientSocket.on('quiz_prepared', (data) => {      expect(data).toHaveProperty('roomCode');      console.log(`Quiz prepared for room: ${data.roomCode}`);      done();    });    clientSocket.on('error_occurred', (data) => {      throw new Error(`An error occurred: ${data.message}`);    });  }, 30000);    afterEach(() => {    clientSocket.off('room_created');    clientSocket.off('quiz_prepared');    clientSocket.off('error_occurred');  });}); ---Directory: utilitiesFile: SendEmail.js --- const sgMail = require('@sendgrid/mail');const appRoot = require('app-root-path');require('dotenv').config({ path: `${appRoot}/.env` });async function sendEmail({ to, subject, html, from = 'contact@classclash.io', fromName = 'Class Clash' }) {  sgMail.setApiKey(process.env.SENDGRID_API_KEY);  const msg = {    to, // recipient email    from: { email: from, name: fromName }, // verified sender email with name    subject,    html,  };  try {    await sgMail.send(msg);    console.log('Email sent');  } catch (error) {    console.error('Failed to send email:', error);    throw new Error(error);  }}module.exports = sendEmail; ---File: addActivityLog.js --- // activityLogger.jsconst db = require('../db/db');const sendEmail = require('./SendEmail');const validLogNames = [    'player_joined',    'room_created',    'clash_started',    'bot_clash_started',    'clash_replayed',    'bot_clash_replayed',    'suggestion_received'  ];  const addActivityLog = async ({ logName, logData }) => {    if (!validLogNames.includes(logName)) {      console.error('Invalid log name:', logName);      return; // Exit the function if logName is not valid    }      try {      await db('activity_log').insert({        activity_log_name: logName,        activity_log_data: JSON.stringify(logData)      });      console.log('Log entry added successfully:', logName);        // Send an email for specific log events with more user-friendly text      if (['player_joined', 'clash_started', 'clash_replayed', 'bot_clash_started'].includes(logName)) {        let emailSubject = `Event Notification: ${logName} - ${new Date().toISOString()}`;        let emailBody = `<p>An event of type <strong>${logName}</strong> has occurred.<br>${JSON.stringify(logData)}</p>`;        switch(logName) {          case 'player_joined':            emailBody = `<p>A new player has signed up<br>${JSON.stringify(logData)}</p>`;            break;          // case 'clash_started':          //   emailBody += `<p>A new clash has started!</p>`;          //   break;          // case 'clash_replayed':          //   emailBody += `<p>A clash is being replayed!</p>`;          //   break;        }          if (process.env.NODE_ENV == 'production') {          await sendEmail({            to: 'contact@classclash.io',            subject: emailSubject,            html: emailBody          });        }        console.log(`Email notification sent for event: ${logName}`);      }    } catch (error) {      console.error('Error adding log entry or sending email:', error);    }  };module.exports = addActivityLog; ---File: addClashDetailsToDatabase.js --- const db = require('../db/db');const addClashDetailsToDatabase = async ({room}) => {    const totalQuestions = room.room_data.quiz.questions.length;    const currentQuestionIndex = room.room_data.currentQuestionIndex + 1;    const clashQuizCompletionPercentage = Math.round((currentQuestionIndex / totalQuestions) * 100);    const clashStartTime = new Date(room.room_data.currentClashStartedAt).getTime();    const clashDuration = Math.round((Date.now() - clashStartTime) / 1000); // Duration in seconds    try {        const query = `            INSERT INTO clash (room_id, quiz_id, clash_quiz_completion_percentage, clash_duration, clash_player_ids)            VALUES (?, ?, ?, ?, ?);        `;        await db.raw(query, [            room.room_id,             room.room_data.quiz_id,             clashQuizCompletionPercentage,             clashDuration,             room.room_player_ids        ]);        console.log('Clash details added to database successfully.');    } catch (err) {        console.error('Error adding clash details to database:', err.message);    }};module.exports = addClashDetailsToDatabase; ---File: addQuizToDatabase.js --- const db = require('../db/db');const addQuizToDatabase = async ({ lesson_id, room_id, quiz_lesson_section_title, quiz_lesson_hash, quiz_prompt_hash, quiz_json }) => {    try {        const query = `            INSERT INTO quiz (lesson_id, room_id, quiz_lesson_section_title, quiz_lesson_hash, quiz_prompt_hash, quiz_json)            VALUES (?, ?, ?, ?, ?, ?)            RETURNING *;        `;        const result = await db.raw(query, [lesson_id, room_id, quiz_lesson_section_title, quiz_lesson_hash, quiz_prompt_hash, quiz_json]);        return result.rows[0];    } catch (err) {        console.error(`Error adding quiz to database:`, err.message);    }}module.exports = addQuizToDatabase; ---File: addXpToPlayerTotal.js --- const db = require('../db/db');const addXpToPlayerTotal = async ({playerId, xpToAdd}) => {    try {        // Using db.raw to execute a raw SQL query        const query = `            UPDATE player            SET player_total_xp = player_total_xp + ?            WHERE player_id = ?            RETURNING player_total_xp;`;        const result = await db.raw(query, [xpToAdd, playerId]);        // Depending on the database client, you might need to adjust how you access the result        const updatedXp = result.rows[0].player_total_xp; // Adjust based on your client if needed        console.log(`Added ${xpToAdd} XP to player ${playerId} TOTAL XP. New total XP: ${updatedXp}`);        return updatedXp;    } catch (err) {        console.error(`Error adding XP to player ${playerId}:`, err.message);    }};module.exports = addXpToPlayerTotal;   ---File: botPlayerInteractsInChat.js --- const botPlayerInteractsInChat = async ({ io, room, scenario }) => {    //there is 50% chance that the bot will interact in the chat    //   if (Math.random() < 0.5) return;    //get the id of the bot player where player have isBot true  in the roopm     const botPlayer = room.room_data.playersData.find(player => player.isBot);    if (!botPlayer) return;    async function sendRandomMessage(io, message, isEmoji = false) {        await new Promise(resolve => setTimeout(resolve, 1000));        let roomCode = room.room_code;        io.to(roomCode).emit('receive_message', { message, isEmoji: isEmoji, playerId: botPlayer.basicPlayerData.player_id });    }    if (scenario === 'bot_player_wrong_answer') {        // Add angry emojis and all sorts of negative emojis         const emojis = ["😿", "😿", "😾", "🙈", "😬", "😢", "😞", "😔", "😡", "😠", "😣", "😩", "🐱", "😠", "🤬", "😤", "💢", "👿", "😾", "🤯", "😖", "😣"];                const texts = ["يا خسارة!", "مش مظبوط!", "حظ أوفر المرة الجاية!", "كانت صعبة!", "هجيبها المرة الجاية!", "ماهوش مكتوبلي!", "يا ربي السلامة!", "ما فماش بركة!", "توة نجيبها!", "المرة الجاية !", 'وووووووه'];        // Randomly choose between sending an emoji or text        const useEmoji = Math.random() < 0.5;        let messageToSend;                if (useEmoji) {            const randomEmojiIndex = Math.floor(Math.random() * emojis.length);            messageToSend = emojis[randomEmojiIndex];            sendRandomMessage(io,  messageToSend, true);        } else {            const randomTextIndex = Math.floor(Math.random() * texts.length);            messageToSend = texts[randomTextIndex];            sendRandomMessage(io,  messageToSend, false);        }    }    if (scenario === 'bot_player_correct_answer') {        // Add celebratory emojis        const emojis = [ "🤗","😁","😎","😉","😄", "👏", "🥳", "🤩", "🙌", "😍"];        const texts = ["أنا الأسطورة!", "سهلة وبسيطة!", "مين قدها زيي؟", "صح بالمية!", "أنا الأفضل وهذا واضح!", "فزت والفوز متعة!", "ما فيش حد يقدر عليا!", "النصر ليا!", "أنا البطل يا جماعة!", "محدش يقدر يغلبني!"];        // Randomly choose between sending an emoji or text        const useEmoji = Math.random() < 0.5;        let messageToSend;                if (useEmoji) {            const randomEmojiIndex = Math.floor(Math.random() * emojis.length);            messageToSend = emojis[randomEmojiIndex];            sendRandomMessage(io, messageToSend, true);        } else {            const randomTextIndex = Math.floor(Math.random() * texts.length);            messageToSend = texts[randomTextIndex];            sendRandomMessage(io, messageToSend, false);        }    }}module.exports = botPlayerInteractsInChat; ---File: checkAvailableQuizzesForPlayer.js --- const db = require('../db/db');const clc = require('cli-color');// This function checks if any of the players in the provided array have an available quiz (in this lesson, they did not play before, with the same prompt and lesson hash)const checkAvailableQuizzesForPlayer = async ({ playerIds, lessonId, promptHash, lessonHash, lessonSectionTitle }) => {    console.log(clc.blue('Checking available quizzes: Player IDs:'), clc.yellow(playerIds.join(', ')), clc.blue('Lesson ID:'), clc.yellow(lessonId), clc.blue('Prompt Hash:'), clc.yellow(promptHash), clc.blue('Lesson Hash:'), clc.yellow(lessonHash), clc.blue('Lesson Section Title:'), clc.yellow(lessonSectionTitle));    const query = `    SELECT DISTINCT q.*  -- Select distinct rows from the quiz table to avoid duplicates    FROM quiz q  -- From the quiz table aliased as q    WHERE q.lesson_id = ?  -- Filter quizzes by the lesson ID      AND q.quiz_prompt_hash = ?  -- Filter quizzes by the prompt hash      AND q.quiz_lesson_hash = ?  -- Filter quizzes by the lesson hash      AND q.quiz_lesson_section_title = ?  -- Filter quizzes by the lesson section title      AND NOT EXISTS (  -- Ensure that no entries exist that would disqualify a quiz        SELECT 1  -- Select a constant value; used to check existence        FROM clash c  -- From the clash table aliased as c        WHERE c.quiz_id = q.quiz_id  -- Filter where the quiz IDs match          AND c.clash_player_ids && ARRAY[?]::integer[]  -- Ensure the clash's player IDs array intersects with the provided player IDs array      );      `;  let quizzesForAllPlayers = [];  let quizzesForAnyPlayer = [];  try {        const bots = await db.raw('SELECT player_id FROM player WHERE player_bot = TRUE AND player_id = ANY(?)', [playerIds]);        const nonBotPlayerIds = playerIds.filter(id => !bots.rows.some(bot => bot.player_id === id));    if (nonBotPlayerIds.length === 0) {        console.log(clc.red('No non-bot players found.'));        return [];    }    const result = await db.raw(query, [lessonId, promptHash, lessonHash, lessonSectionTitle, JSON.parse(nonBotPlayerIds)]);    console.log(result.rows)    if (result.rows.length > 0) {      quizzesForAnyPlayer.push(...result.rows);      quizzesForAllPlayers.push(result.rows.map(quiz => quiz.quiz_id));    }    // Find quizzes available for all players    const quizzesAvailableForAll = quizzesForAllPlayers.reduce((acc, curr) => acc.filter(id => curr.includes(id)), quizzesForAllPlayers[0] || []);    if (quizzesAvailableForAll.length > 0) {      console.log(clc.yellow(`Quizzes available for all players found: ${quizzesAvailableForAll.length}.`));      return quizzesForAnyPlayer.filter(quiz => quizzesAvailableForAll.includes(quiz.quiz_id));    }     // Remove duplicate quizzes for any player by quiz_id    const uniqueQuizzesForAnyPlayer = quizzesForAnyPlayer.filter((quiz, index, self) => index === self.findIndex((t) => (t.quiz_id === quiz.quiz_id)));    if (uniqueQuizzesForAnyPlayer.length > 0) {      console.log(clc.yellow(`Unique quizzes for any player found: ${uniqueQuizzesForAnyPlayer.length}.`));    }     return uniqueQuizzesForAnyPlayer;  } catch (error) {    console.error(clc.red(`Error checking available quizzes for players: ${error.message}`));    throw error;  }};module.exports = checkAvailableQuizzesForPlayer; ---File: convertQuizGenerationToStandardStructure.js --- function convertQuizGenerationToStandardStructure(originalObject) {    // Destructure the original object for easier access    const { r, qs } = originalObject;    // Transform the questions    const questions = qs.map(question => ({        question: question.q,        answers: question.a,        correctAnswerJustificationFromLesson: question.j,        difficultyLevel: question.d    }));    // Generate the correctAnswers mapping    const correctAnswers = qs.reduce((acc, question, index) => {        acc[index] = question.c;        return acc;    }, {});    // Return the new structure with expanded key names and the correctAnswers mapping    return {        quizTitle: r,        questions: questions,        correctAnswers: correctAnswers    };}module.exports = convertQuizGenerationToStandardStructure; ---File: deepUpdateInMemoryObject.js --- function deepUpdateInMemoryObject(obj, pathParts, newValue) {    let current = obj;    for (let i = 0; i < pathParts.length - 1; i++) {        const part = pathParts[i];        // Check if the current part includes an array index        if (part.includes('[')) {            const [key, index] = part.split(/\[|\]/).filter(Boolean);            // Ensure the array exists            current[key] = current[key] || [];            // Ensure the array is large enough            while (current[key].length <= index) {                current[key].push({});            }            current = current[key][parseInt(index, 10)];        } else {            // Ensure the object exists            current[part] = current[part] || {};            current = current[part];        }    }    const finalPart = pathParts[pathParts.length - 1];    if (finalPart.includes('[')) {        const [key, index] = finalPart.split(/\[|\]/).filter(Boolean);        current[key][parseInt(index, 10)] = newValue;    } else {        current[finalPart] = newValue;    }}module.exports = deepUpdateInMemoryObject; ---File: generateHashFromText.js --- const crypto = require('crypto');function generateHashFromText(str) {  const hash = crypto.createHash('md5');  hash.update(str);  const hashValue = hash.digest('hex');  return hashValue.substring(0, 15);}module.exports = generateHashFromText; ---File: generateMultipleChoiceQuizObject.js --- const useGeminiAPI = require('./useGeminiAPI');const useGPT4API = require('./useGPT4API');const {useGeminiProAPI, useGeminiProApiWithQueue} = require('./useGeminiProAPI');const convertQuizGenerationToStandardStructure = require('./convertQuizGenerationToStandardStructure.js')const generateHashFromText = require('./generateHashFromText');const addQuizToDatabase = require('./addQuizToDatabase');const checkAvailableQuizzesForPlayer = require('./checkAvailableQuizzesForPlayer');const clc = require('cli-color');const getQuestionsFromSimilarQuizzes = require('./getQuestionsFromSimilarQuizzes');const generateMultipleChoiceQuizObject = async ({ lessonContent, previousQuizQuestions=[], selectedLessonSection, playerIds, lessonId, lessonTitle }) => {    if (Array.isArray(previousQuizQuestions)) {        previousQuizQuestions = previousQuizQuestions.join('\n');    }    if (!selectedLessonSection?.sectionTitle || !selectedLessonSection?.sectionContent) {        console.error(clc.red('MISSING LESSON SECTION in generateMultipleChoiceQuizObject:  title or content, something\'s wrong.'));    }    let prompt = `    IDEA: quick and fun trivia quiz played by students to revise a lesson     Read the lesson text taken from a textbook from the Tunisian educational program:    ==    lesson title: ${lessonTitle}    selected part of the lesson text:    title: ${selectedLessonSection?.sectionTitle}    content: ${selectedLessonSection?.sectionContent}    ===            MISSION TO DO:    you are an elite teacher and you need to create a fun and engaging quiz for your students to test both their knowledge understanding of the lesson content..    you have to fulfil this duty and make sure the students have better understanding of the lesson content after doing your quiz.    implement the Socratic method and storytelling to make the questions more engaging and more useful for the students.         it's important for students to retain the information but also make it engaging and fun, use storytelling and hints to make the questions more engaging and fun to play.     fun is very important so the quiz should be mostly fun with storytelling, obvious answers and hints but educational with cramming as much info as we can. main goal is to make studying actually ENTERTAINING. make this a fun experience (we are gamifying education here)        read the lesson, take a deep breath and create a series of 10 questions on it for a certain part of the lesson ==>  the series of questions shoud be connected and a question can refer to the previous question to make a narrative and a coherent story==> don't make questions just about the surface information, but about the MEANING and CONTEXT and SUBTEXT behind the information==>  STRICT : ONLY  use information from the provided text to make questions. this is to ensure we don't quiz student about stuff not in the educational program! ==> each question would usually have 4 possible answers but it can vary depending on the question (if it's a yes/no question or true/false question or a different type of question, etc.)==> questions should be in SAME LANGUAGE AS LESSON==> provide context in the question and assume the student didn't read the lesson text, so make sure the questions are clear and understandable (don't use "that", "this", "it", "then" etc. be specific and name things don't be afraid to be verbose if necessary to avoid confusion)==> most questions should be very easy, quick and fun, but cover as much information as possible from the text==> do not miss putting the correct answer index for every question (in a random order)==> repetition can be healthy for learning, so don't be afraid to repeat information in different questions, but don't make it too repetitive or boringEND GAME: student should be able to form a paragraph after playing this quiz using the information they got from the questions and answers. form a coherent narrative and story from the questions and answers.EXAMPLE RESPONSE FORMAT (Ensure the format is clear and structured), return as a json, only return the json object nothing else is expected:{    "r": "quiz title like the topics and stuff from the lesson we're quizzing on",    "qs": [      {        "q": "Example Question",        "a": ["Answer 0", "Answer 1", "Answer 2", "Answer 3"],        "c": [0], <== c is for correct answer index, index is 0 based, so 0 is the first answer, 1 is the second answer, etc.        "j": "Explanation or lesson excerpt justifying the correct answer",        "d": "easy/medium/hard"      },      {        "q": "Another Example Question",        "a": ["Answer 0", "Answer 1", "Answer 2", "Answer 3"],        "c": [2],        "j": "Explanation or lesson excerpt justifying the correct answer",        "d": "easy/medium/hard"      },      //more questions    ]  }note: to save token space, return the json without any linebreaks, just a single line of json object. NO LINE BREAKS IN THE RESPONSE, JUST A SINGLE LINE OF JSON OBJECT.`    //remove all linebreaks from the priompt to save tokens    prompt = prompt.replace(/\n/g, " ")    let response;    let quiz_id;        const availableQuizzes = await checkAvailableQuizzesForPlayer({        playerIds: playerIds, // This should be replaced with the actual current player's ID        lessonId: lessonId, // This should be replaced with the ID of the current lesson        promptHash: generateHashFromText(JSON.stringify(prompt)), // This should be replaced with the hash of the current prompt        lessonHash: generateHashFromText(JSON.stringify(lessonContent)),        lessonSectionTitle: selectedLessonSection?.sectionTitle    });    if (availableQuizzes.length > 0) {        console.log(clc.yellow('AVAILABLE QUIZZES FOUND, USING ONE OF THEM INSTEAD OF GENERATING A NEW QUIZ'));        response = availableQuizzes[0]?.quiz_json // This is a simplification, you might want to select the quiz more carefully        quiz_id = availableQuizzes[0]?.quiz_id    } else {        console.log(clc.yellow('NO AVAILABLE QUIZZES FOUND, GENERATING A NEW QUIZ...'))        const questionsFromOtherSimilarQuizzes = await getQuestionsFromSimilarQuizzes({            lessonId: lessonId,            promptHash: generateHashFromText(JSON.stringify(prompt)),            lessonHash: generateHashFromText(JSON.stringify(lessonContent)),            lessonSectionTitle: selectedLessonSection?.sectionTitle        });        console.log(clc.green(`we got ${questionsFromOtherSimilarQuizzes?.length} questions from other similar quizzes`));        console.log({questionsFromOtherSimilarQuizzes})        //generate a quiz using the AI API     //   console.log(prompt)                    let parts = [            { text: prompt },            {text: `${questionsFromOtherSimilarQuizzes?.length> 0 ? `            PREVIOUS QUIZZES QUESTIONS: DO NOT REPEAT THIS THESE ALREADY USED QUESTIONS (because repeating questions makes the quiz  boring and repetitive) DO NOT make similar questions or variations of these old questions:            ===            ${questionsFromOtherSimilarQuizzes.join(' - \n')}            ===            ` : ''}`}        ]        let attempts = 0;        const maxAttempts = 3;        while (attempts < maxAttempts) {            try {                //response = await useGeminiAPI({ parts });              //  response = await useGPT4API({ parts });                response = await useGeminiProApiWithQueue({ parts });                response = convertQuizGenerationToStandardStructure(response)                //JSON.parse(response); // This will throw an error if the response is not valid JSON                break; // If the request is successful and the response is valid JSON, exit the loop            } catch (error) {                console.error(`Attempt ${attempts + 1} failed`);                attempts++;                if (attempts === maxAttempts) {                    console.log(response)                    throw new Error('Failed to interact with Gemini after 3 attempts or response is not valid JSON');                }            }        }    }    //only parse response if it's a json object not a javascritp object     if (typeof response === 'string') {        response = JSON.parse(response);    }    return { newQuiz: response, prompt, quizId: quiz_id };}module.exports = generateMultipleChoiceQuizObject;/*    let prompt = `IDEA: quick and fun trivia quiz played by students to revise a lesson Read the lesson text taken from a textbook from the Tunisian educational program:==lesson title: ${lessonTitle}selected part of the lesson text:title: ${selectedLessonSection?.sectionTitle}content: ${selectedLessonSection?.sectionContent}===MISSION TO DO:you are an elite teacher and you need to create a fun and engaging quiz for your students to test both their knowledge understanding of the lesson content..you have to fulfil this duty and make sure the students have better understanding of the lesson content after doing your quiz.implement the Socratic method and storytelling to make the questions more engaging and more useful for the students. it's important for students to retain the information but also make it engaging and fun, use storytelling and hints to make the questions more engaging and fun to play. fun is very important so the quiz should be mostly fun with storytelling, obvious answers and hints but educational with cramming as much info as we can. main goal is to make studying actually ENTERTAINING. make this a fun experience (we are gamifying education here)PRIOTITIES: 1/ fun and being engaged and entertained 2/ player feeling smart (by making quiz easy with hints and obvious answers and leading player to answer) 3/ learning read the lesson, take a deep breath and create a series of 10 questions on it for a certain part of the lesson ==>  the series of questions shoud be connected and a question can refer to the previous question to make a narrative and a coherent story==> don't make questions just about the surface information, but about the MEANING and CONTEXT and SUBTEXT behind the information==>  STRICT : ONLY  use information from the provided text to make questions. this is to ensure we don't quiz student about stuff not in the educational program! ==> each question would usually have 4 possible answers but it can vary depending on the question (if it's a yes/no question or true/false question or a different type of question, etc.)==> questions should be in SAME LANGUAGE AS LESSON==> provide context in the question and assume the student didn't read the lesson text, so make sure the questions are clear and understandable (don't use "that", "this", "it", "then" etc. be specific and name things don't be afraid to be verbose if necessary to avoid confusion)==> most questions should be very easy, quick and fun, but cover as much information as possible from the text==> do not miss putting the correct answer index for every question (in a random order)==> repetition can be healthy for learning, so don't be afraid to repeat information in different questions, but don't make it too repetitive or boringEND GAME: student should be able to form a paragraph after playing this quiz using the information they got from the questions and answers. form a coherent narrative and story from the questions and answers.EXAMPLE RESPONSE FORMAT (Ensure the format is clear and structured), return as a json, only return the json object nothing else is expected:{    "r": "quiz title like the topics and stuff from the lesson we're quizzing on",    "qs": [      {        "q": "Example Question",        "a": ["Answer 0", "Answer 1", "Answer 2", "Answer 3"],        "c": [0], <== c is for correct answer index, index is 0 based, so 0 is the first answer, 1 is the second answer, etc.        "j": "Explanation or lesson excerpt justifying the correct answer",        "d": "easy/medium/hard"      },      {        "q": "Another Example Question",        "a": ["Answer 0", "Answer 1", "Answer 2", "Answer 3"],        "c": [2],        "j": "Explanation or lesson excerpt justifying the correct answer",        "d": "easy/medium/hard"      },      //more questions    ]  }note: to save token space, return the json without any linebreaks, just a single line of json object. NO LINE BREAKS IN THE RESPONSE, JUST A SINGLE LINE OF JSON OBJECT.`*//* IMPORTANT EXCEPTION : IF SUBJECT IS RELATED/CONTAINS MATHS OR ADVANCED PHJYSICS we have these exceptions: -- ==>NO storytelling, NO humor, NO fun personnality, NO fun examples, we need to be serious and direct and straightforward with the questions and answers. ==> DROP the fun and engaging part, this is serious stuff, we are talking about MATHS and ADVANCED PHYSICS here.==> entertainement is not a priority if we have a maths related subject or advanced physics, be blunt and direct and straightforward with the questions and answers.==> make the questions as clear and direct as possible, and give hints and make it as easy as possible.==> be absolutely direct and straightforward with the questions and answers. clear and direct for those subjects. ==> encircle any maths expressions with "$" for example : "$𝑓(𝑥) = (3𝑥 − 2)𝑒^(2𝑥)$"-- *//* Most of the questions should be EASY.*//*المطلوب:قسم الدرس إلى أجزاء منطقية حسب فصول أو مواضيع الدرس (إذا كان الدرس طويل كفاية لذلك)إختر جزء عشوائي من أجزاء هذا الدرس لإنشاء الأسئلة عنه (فقرة معينة من الدرس أو إذا كان الدرس قصير يمكنك إختيار الدرس كاملا). إختر جزأ عشوائي  من أي مكان في الدرس ليس بالضرورة أن يكون في بدايته أو نهايته. لأن اللاعب قد يكون لعب هذا الدرس من قبل لذلك كن عششوائي حتى لا يمل التلميذ من إعادة اللعبقم إنشاء 8 أسئلة لإختبار المعلومات الموجودة كل سؤال له 4 إجابات محتملة واحدة منهم فقط صحيحةأغلب الأسئلة يجب أن تكون سهلة .احرص على تكوين الأسئلة عبر إستعمال المعلومات الموجودة في هذا النص فقط.لا تستعمل "جميع ما سبق" أو "جميع الإجابات صحيحة" أو ما يماثلهما كإجابة محتملةمهم: قم بإختيار فقرة من النص و قم بإنشاء الأسئلة عليها، لا تقم بإنشاء الأسئلة من أماكن متفرقة عشوائية من النص , الأسئلة المتتالية يجب أن تكون مترابطة مع بعضها البعض  حتى يتمكن التلميذ من فهم الموضوع بشكل أفضل.MISSION TO DO:CREATE questions to test the information contained (MINIMUM 10 questions, but no more than 20 questions) so grab that chosen text part and MILK as many QUESTIONS out of it as possible out of all bits of INFO and MEANING  in it to create questionsEach question should have 4 possible answers, only one of them is correct.initial questions should be EASY, but it becomes harder as you go along to more questionsEnsure to form the questions using only the information found in this part of text.plan the questions well meaning the consecutive questions should be related to each other so that the student can better understand the subject. the series of created questions should be COHERENT and make sense. this is NOT a trivia game, this will help the student go through the lesson content and understand it and pick the details by answering questions about it.questions should not be just about surface information but about MEANING and SUBTEXT behind the information, so the student can understand the lesson better.IMPORTANT: questions should be in SAME LANGUAGE AS LESSON.note: students don't have access to the lesson content text, only the questions and answers, so make sure the questions are clear and understandable.لا تستعمل "جميع ما سبق" أو "جميع الإجابات صحيحة" أو "لا شيء مما ذكر" أو ما يماثلهم كإجابة محتملة، كل إجابة يجب أن تكون فريدة.==>ONLY USE THE INFORMATION IN THE GIVEN SELECTED PART OF THE LESSON---==> MINIMUM 5 questions, MAXIMUM 15 questions==> each question would have 4 possible answers.==> questions should be connected to each other and make sense. pick a narrative and be consistent with it.==> BE CREATIVE IN MAKING THE QUIZ QUESTIONS FUN AND ENGAGING==>questions should be in SAME LANGUAGE AS LESSONRead the full lesson text taken from a textbook from the Tunisian educational program:"${lessonContent}"THE PART WE ARE INTERESTED IN : "${selectedPart}"*/ ---File: generateRoomCode.js --- const db = require('../db/db');const {ROOM_CODE_WORDS}  = require('../constants');async function generateRoomCode() {    let roomCodeExists = true;    let roomCode = '';    while (roomCodeExists) {        const randomWord = ROOM_CODE_WORDS[Math.floor(Math.random() * ROOM_CODE_WORDS.length)].toUpperCase();        const randomNumber = Math.floor(Math.random() * 10); // 0 to 9        roomCode = `${randomWord}${randomNumber}`;        // roomCode = `${randomWord}`;        const existingRoom = await db('room')            .where({ room_code: roomCode, room_active: true })            .first();        if (!existingRoom) {            roomCodeExists = false;        }    }    return roomCode;}module.exports = generateRoomCode; ---File: getAndSplitAllLessonsIntoSections.js --- const db = require('../db/db');const splitLessonContentIntoSections = require('./splitLessonContentIntoSections');  const getAndSplitAllLessonsIntoSections = async () => {    try {        const query = `            SELECT lesson_id, lesson_content, lesson_sections FROM lesson;        `;        const result = await db.raw(query);        const lessons = result.rows;        const lessonsWithSectionsPromises = lessons.map(async (lesson) => {            if (lesson.lesson_sections) {                return Promise.resolve({ lesson_id: lesson.lesson_id, sections: lesson.lesson_sections });            } else {                const sections = await splitLessonContentIntoSections(lesson.lesson_content);                // Update lesson_sections column with the new sections                await db('lesson')                    .where({ lesson_id: lesson.lesson_id })                    .update({ lesson_sections: sections });                return { lesson_id: lesson.lesson_id, sections };            }        });        const lessonsWithSections = await Promise.all(lessonsWithSectionsPromises);        return lessonsWithSections;    } catch (err) {        console.error(`Error getting and splitting all lessons into sections:`, err.message);    }}module.exports = getAndSplitAllLessonsIntoSections; ---File: getBotUser.js --- const db = require('../db/db');async function getRandomBotUser() {    try {        const bot = await db('player')            .where('player_bot', true)            .orderByRaw('RANDOM()')            .first();            if (!bot?.player_profile_picture_url || bot?.player_profile_picture_url.trim() === '') {                bot.player_profile_picture_url = `https://api.dicebear.com/8.x/initials/svg?seed=${bot?.player_first_name}&&backgroundType=gradientLinear,solid`;            }        return bot;                       } catch (error) {        console.error('Failed to fetch a random bot user:', error);        return null;    }}module.exports = getRandomBotUser; ---File: getLessonById.js --- const db = require('../db/db')const getLessonById = async (lessonId) => {    const lesson = await db.raw('SELECT * FROM lesson WHERE lesson_id = ?', [lessonId]);     return lesson.rows[0];}module.exports = getLessonById; ---File: getQuestionsFromSimilarQuizzes.js --- const db = require('../db/db');const clc = require('cli-color');const getQuestionsFromSimilarQuizzes = async ({ lessonId, promptHash, lessonHash, lessonSectionTitle }) => {    console.log(clc.blue('Fetching questions from similar quizzes: Lesson ID:'), clc.yellow(lessonId), clc.blue(', Prompt Hash:'), clc.yellow(promptHash), clc.blue(', Lesson Hash:'), clc.yellow(lessonHash), clc.blue(', Lesson Section Title:'), clc.yellow(lessonSectionTitle));    // Query to get all quizzes with the same lesson_id, prompt_hash, lesson_hash, lesson_section_title, sorted by most recent    const query = `    SELECT q.*    FROM quiz q    WHERE q.lesson_id = ?      AND q.quiz_prompt_hash = ?      AND q.quiz_lesson_hash = ?      AND q.quiz_lesson_section_title = ?    ORDER BY q.quiz_timestamp DESC;    `;    try {        const result = await db.raw(query, [lessonId, promptHash, lessonHash, lessonSectionTitle]);        const allQuestionItems = result.rows.flatMap(quiz => (quiz.quiz_json).questions.map(question => question.question));        //latest 15 questions is enough to ensure we are not repeating the same questions across this lesson's section since section are usually short + we don't want to pus the ai and start making up irrelevant questions        const questionItems = allQuestionItems.slice(0, 15);        return questionItems.length > 0 ? questionItems : [];    }    catch (error) {        console.error(`Error getting similar quizzes questions:`, error.message);    }}module.exports = getQuestionsFromSimilarQuizzes; ---File: getQuizWithoutCorrectAnswers.js --- function getQuizWithoutCorrectAnswers(quiz) {    // Using JSON.parse(JSON.stringify()) to deep copy the quiz object    // so the original quizzes object isn't modified.    let quizCopy = JSON.parse(JSON.stringify(quiz));    delete quizCopy.correctAnswers; // Remove the correctAnswers key    return quizCopy;  }module.exports = getQuizWithoutCorrectAnswers; ---File: incrementLessonPlayCount.js --- const db = require('../db/db');const incrementLessonPlayCount = async (lessonId) => {    await db.raw(        'UPDATE lesson SET lesson_play_count = lesson_play_count + 1 WHERE lesson_id = ?',        [lessonId]    ); }module.exports = incrementLessonPlayCount; ---File: incrementPlayerQuizCounts.js --- const db = require('../db/db');const clc = require('cli-color');const incrementPlayerQuizCounts = async ({playerIds, roomCode}) => {    console.log(`${clc.bgWhite.black(roomCode)}: Incrementing quiz counts for players: ${playerIds.join(', ')}`);    const query = `        UPDATE player        SET player_daily_quiz_count = player_daily_quiz_count + 1,            player_lifetime_quiz_count = player_lifetime_quiz_count + 1        WHERE player_id = ANY(?)    `;    await db.raw(query, [playerIds]);};module.exports = incrementPlayerQuizCounts; ---File: resetAllPlayersDailyQuizCount.js --- const db = require('../db/db');const resetAllPlayersDailyQuizCount = async () => {    // Update player_daily_quiz_count to 0 and set player_last_daily_quiz_count_reset to the current timestamp    const result = await db.raw(        'UPDATE player SET player_daily_quiz_count = 0, player_last_daily_quiz_count_reset = NOW()'    );    console.log(`Reset daily quiz count for ${result.rowCount} players.`);    return result;};module.exports = resetAllPlayersDailyQuizCount; ---File: sendFacebookRegistrationEvent.js --- 'use strict';const bizSdk = require('facebook-nodejs-business-sdk');const ServerEvent = bizSdk.ServerEvent;const EventRequest = bizSdk.EventRequest;const UserData = bizSdk.UserData;const CustomData = bizSdk.CustomData;const Content = bizSdk.Content;const access_token = 'EAAFnAZBbrTZAgBOyVqQ5HcFc31yDOROeu14hQ2UrPLXY4IkWEEnjYRQzFIDUZA1mxnFfbRiyNsH5SymBXDLfoMeJHDTCf1xHfQzCIYs67EjRvWo6PA7fzaChVQ2aOKrg3pjorF2keol6vJcGZC7dxfS6PWhoDv07RPHSu3hISm5F6h2fj9wBZCsaRFpZBW5rgCZAQZDZD';const pixel_id = '1505626326715907';const api = bizSdk.FacebookAdsApi.init(access_token);const sendFacebookRegistrationEvent = ({ email, phone, first_name, last_name, city, country, user_id, ip_adresse, user_agent, current_timestamp, eventID }) => {    const userData_0 = (new UserData())        .setEmails([email])       // .setPhones([phone])        .setLastNames([last_name])        .setFirstNames([first_name])        //.setCities([city])       // .setCountries([country])        .setExternalIds([user_id])        .setClientIpAddress(ip_adresse)        .setClientUserAgent(user_agent);    const serverEvent_0 = (new ServerEvent())        .setEventName("CompleteRegistration")        .setEventTime(current_timestamp)        .setEventId(eventID)        .setUserData(userData_0)        .setActionSource("website")        .setEventSourceUrl("https:\/\/classclash.io");    const eventsData = [serverEvent_0];    const eventRequest = (new EventRequest(access_token, pixel_id))        .setEvents(eventsData);    eventRequest.execute();    console.log('Facebook Registration Event Sent')}module.exports = sendFacebookRegistrationEvent ---File: splitLessonContentIntoSections.js --- const useGeminiAPI = require('./useGeminiAPI.js');const useGPT4API = require('./useGPT4API.js');const useLlamaAPI = require('./useLlamaAPI.js');const {useGeminiProAPI} = require('./useGeminiProAPI.js');const splitLessonContentIntoSections = (text) => {  const maxSectionLength = 1500;  const extendedSearchRange = 500;  const sections = [];  let currentIndex = 0;  while (currentIndex < text.length) {    let endIndex = currentIndex + maxSectionLength;    let extendedEndIndex = Math.min(currentIndex + maxSectionLength + extendedSearchRange, text.length);    // Find the nearest newline or space before extendedEndIndex    let nearestNewline = text.indexOf('\n', currentIndex);    while (nearestNewline !== -1 && nearestNewline <= extendedEndIndex && nearestNewline < text.length) {      if (nearestNewline > endIndex && nearestNewline <= extendedEndIndex) {        endIndex = nearestNewline;        break;      }      nearestNewline = text.indexOf('\n', nearestNewline + 1);    }    // If no suitable newline, then find the nearest space before maxSectionLength    if (endIndex === currentIndex + maxSectionLength) {      let lastSpace = text.lastIndexOf(' ', endIndex);      if (lastSpace > currentIndex) {        endIndex = lastSpace;      }    }    // Ensure the section is not empty or just whitespace    const sectionContent = text.substring(currentIndex, endIndex).trim();    if (sectionContent) {      const sectionTitle = `Section ${sections.length + 1}`;      sections.push({ sectionTitle, sectionContent });    }    currentIndex = endIndex + 1;  }  // Handle the case for the last section being too short  if (sections.length > 1 && sections[sections.length - 1].sectionContent.length < 500) {    sections[sections.length - 2].sectionContent += ' ' + sections.pop().sectionContent;  }//loop thourhg the sections and log   sections.forEach((section, index) => {    console.log(`Section ${index + 1}: `);    console.log(section);  });  console.log(`Total number of sections: ${sections.length}`);  return { sections };}module.exports = splitLessonContentIntoSections;const exampleLesson = `مقدمةتمثّل أدفاق السّياحة العالميّة أحد مظاهر العولمة واربتط ظهورها بالسّياحة الجماهريّة وتطوّر وسائل النّقل وأدّى تنامي هذه الأدفاق إلى نشأة أدفاق هامّة ومن ذلك تدعيم التّرابط بين بلدان العالم.أدفاق سياحيّة عالميّة متنامية:نمو سريع للأدفاق السّياحيّة العالميّة:عرفت أدفاق السّياحة العالميّة نموًّا هامًّا منذ نهاية الحرب العالميّة الثّانية حيث مرّ عدد السّياح من 25.3 مليون سائح سنة 1950 إلى مليار 323 مليون سائح في 2017 ومن المتوقّع أن يبلغ سنة 2020 مليار و600 مليون سائح وقد مرّ هذا النّمو بثلاثة مراحل:فترة نمو مرتفع:ميّزت فترة الخمسينات والسّتينات من القرن العشرين وهي فترة انطلاق الظّاهرة السّياحيّة وتزامنت مع فترة النّمو الاقتصادي السّريع بعد الحرب العالميّة الثّانية واكتساب السّياحة العالميّة طابعا جماهريًّا (هي نمط سياحي ظهر بالبلدان الصّناعيّة خلال الستّينات من القرن العشرين بفضل تعميم العطل الخالصة الأجر ممّا مكّن الجماهير الشّعبيّة من السّفر لغرض السّياحة).فترة نموّ متوسّط:ميّزت السّبعينات والثّمانينات والتّسعينات من القرن العشرين وارتبطت بأزمات اقتصادية مثل الصّدمتين النّفطيّتين خاصّة منها الصّدمة الثّانية التي أدّت إلى ركود السّياحة خلال ثلاث سنوات (1981 – 1982 – 1983).فترة نمو ضعيف ومتذبذب:ميزت العشرين الأولى من القرن الواحد والعشرين لتواتر عدّة أحداث منها أحداث 11 سبتمبر 2011 وكارثة تسونامي 26 ديسمبر 2004 والأزمة الماليّة سنة 2008.أدفاق سياحيّة مرتبطة أساسا بدول الشّمال:الأدفاق الرّئيسية والثّانويّة للسّياحة العالميّة:تمثّل بلدان الشّمال المناطق الكبرى لانطلاق الأدفاق السّياحيّة الرّئيسيّة العالميّة واستقبالها فهي توفّر وتستقبل ثلثي السّيّاح في العالم حيث تساهم البلدان الأوروبيّة بنحو 52 % من عدد السّياح المغادرين تليها بلدان أمريكا الشّماليّة بـ 10% حيث نجد 6 بلدان متقدّمة ضمن قائمة البلدان العشر الأولى التي تساهم بثلث عدد السيّاح الوافدين في العالم.أمّا الأدفاق الثّانويّة فهي من بلدان الشّمال إلى بلدان الجنوب:من أمريكا الشّمالية نحو جزر الكراييب وأمريكا اللّاتينيّة (المكسيك والبرازيل).من أوروبا إلى بلدان الضفّة الجنوبيّة للبحر المتوسّط (مصر – تونس – المغرب).من أوروبا نحو شرق آسيا مثل الصّين وماليزيا وهونغ كونغ وتايلندا والفلبّين وهناك أدفاق ثانويّة أخرى تنطلق من اليابان نحو جزر المحيط الهادي.وقد شهدت هذه الأدفاق الثّانويّة نموّا هامّا ممّا رفع حصّتها في السّياحة العالميّة إلى 46% من عدد السّياح الوافدين سنة 2009.انعكاسات مجاليّة هامّة للأدفاق السّياحيّة العالميّة:ساهمت الأدفاق السّياحيّة في ظهور مجالات سياحيّة كبرى:منطقة البحر الأبيض المتوسّط تحتلّ المرتبة الأولى حيث تستقطب حوالي 150 مليون سائح سنويّا نظرا لتزايد الطّلب على السّياحة الاستحماميّة (مزايا طبيعيّة وتجهيزات سياحيّة متطوّرة…).سواحل خليج المكسيك (فلوريدا والسّاحل الأمريكي) حيث تستقطب السّياح الأثرياء من بقيّة التّراب الأمريكي وهناك بعض الأراضي الجبليّة السّياحيّة مثل جبال الآلب إضافة إلى سياحة المدن الكبرى مثل باريس حيث تستقطب أكثر من 50 مليون سائح ولندن ومدريد وروما في إطار سياحة ثقافيّة وسياحة المؤتمرات والأعمال كذلك المدن الدّينيّة مثل مكّة، المدينة المنوّرة، روما وبيت لحم.عائدات سياحيّة متنامية:تطوّرت العائدات السّياحيّة للسّياحة العالميّة حيث نمت وارتفعت بـ 48 مليار دولار سنة 2014 لتصل إلى مستوى قياسي قدّر بــ 1.49 مليار دولار وتهيمن بلدان الشّمال على العائدات الماديّة السياحيّة بقيمة الثّلثين. وتأتي أوروبا في المرتبة الأولى بنسبة 41% من جملة العائدات أي 509 مليار دولار ثم حلّت آسيا ومنطقة المحيط الهادي في المرتبة الثّانية بحوالي 30 % من العائدات أي 377 مليار دولار ثم أمريكا بـ 22% أي 274 مليار دولار والشّرق الأوسط بـ 49 مليار دولار وإفريقيا بـ36 مليار دولار. وقد حقّقت بعض البلدان الجنوبيّة مثل ماليزيا وتركيا مداخيل هامّة من السّياحة مستفيدة من الاستثمارات في البنية السّياحيّة ومن العائدات الماليّة من السّياحة العالميّة باعتبارها من السّياحات القليلة ذات الحاصل الإيجابي مع بلدان الشّمال.عوامل تنامي الأدفاق السّياحيّة العالميّة:تحسّن مستوى العيش:ساهم ارتفاع مستوى الدّخل الأسري في دول الشّمال خاصّة في تزايد النّفقات السّياحيّة من الإنفاق الأسري وتعتبر أحد العوامل الاقتصادية الهامّة في تحريك الأدفاق السياحيّة فكلّما ارتفع مستوى دخل الأسرة، ازدادت نسبة الإقبال على السّياحة ففي فرنسا 62 % من الأسر الفرنسيّة سافرت من أجل السّياحة و80% لدى من يفوق دخلهم 7600 يورو في السّنة، كما ساهمت الحكومات في تنشيط السّياحة من خلال:تعميم التّمتّع بالعطل خليصة الأجر مع إضافة الأسبوع الخامس في فرنسا.تقليص مدّة العمل الأسبوعي من 45 ساعة إلى 35 ساعة في بداية القرن العشرين.مكّنت هذه الإجراءات السّياحيّة من اكتساب السّيمة الجماهريّة.سياسات تنمويّة تراهن على السّياحة العالميّة:السّياحة هو نشاط قادر أكثر من غيره على توفير مواطن الشّغل والعملة الصّعبة فأقرت عدّة بلدان خاصة الشّمال برامج ومخطّطات للتّهيئة السّياحيّة ورصد إستثمارات ضخمة للبنية الأساسيّة. وقد راهنت بلدان الجنوب على القطاع السّياحي مثل البلاد التّونسيّة والمغرب الأقصى ومصر وجزر الكراييب من خلال تهيئة المناطق السّياحيّة ببناء الفنادق والتّفويت فيها للخواص وتشجيع الرّأسمالي المحلّي والأجنبي على الاستثمار في السّياحة. كما اعتمدت بعض دول الخليج النّفطيّة على السّياحة مثل دبي تحسّبا لنفاد مواردها. ووفّر هذا المجال 266 مليون موطن شغل بصفة مباشرة وغير مباشرة حول العالم فيما مثّلت السّياحة 7% من النّاتج الدّاخلي الخام بفرنسا ووفرت 1 مليون موطن شغل في جزر الكراييب فضلا عن توفيرها بين 70 % و90% من ناتجها الدّاخلي.دور وسائل النّقل والاتصال:أدّى التّطوّر التّقني في وسائل النّقل واحتداد المنافسة بينها إلى:تخفيض تكاليف السّفر حيث ساهم النّقل الجوّي في ازدهار السّياحة الجماهريّة خاصّة بالمناطق البعيدة عن أوروبا.تعميم الرّحلات المنظّمة ذات الكلفة المنخفضة (Vols Charters).توسيع السّوق السّياحيّة العالميّة بفتح مجالات سياحيّة بعيدة عن أوروبا مثل إفريقيا وتدعّمت خاصّة بفكّ التّقنين عن النّقل الجوّي في 1979 في الولايات المتّحدة الأمريكيّة و1986 بالاتحاد الأوروبي.ظهور شركات نقل جوّي قادرة على تنظيم رحلات بأسعار رخيصة (Cost Rom) وإستفادت السياحة من ثورة وسائل الاتصال بتعميم استعمال الأنترنت في عمليات الحجز والعمليّات الماليّة والتّراسل الإلكتروني.تطوّر العرض السّياحي:تطوّرت طاقة الإيواء العالميّة لتفوق 20 مليون غرفة فندقية في 2012 وتحتكر بلدان الشّمال ثلثي هذه الطّاقة وقد سجّلت دول آسيا الشّرقيّة وبلدان المحيط الهادي وإفريقيا نموّا هامّا تضاعف بتسع مرّات بآسيا الشّرقيّة وثلاث مرّات بإفريقيا.ولم يعد العرض السّياحي يقتصر على الغرف الفندقيّة والإقامات الثّانويّة حيث توجّه نحو التّنوّع.القوى السياحيّة المندمجة: لكن تبقى الغرف الفندقيّة من أهم أشكال العرض السّياحي وبالتّوازي تميّز المنتوج السّياحي بالتّنوّع:السياحة البيئيّة.السياحة الإستشفائيّة.السياحة الشّاطئيّة.السياحة الدّينيّة.السياحة الثّقافيّة.وتبقى أدفاق السّياحة العالميّة رهينة ظروف اقتصادية وأمنيّة معيّنة.الأطراف المتدخّلة:الأطراف العموميّة والدّوليّة والمنظّمات الغير حكوميّة:الأطراف العموميّة:تتكوّن من الجماعات المحليّة كالبلديات في تونس ومن وزارات كوزارة السّياحة ووزارات السّيادة مثل وزارة الخارجيّة إضافة إلى الدّواوين المختصّة مثل الدّيوان الوطني للسياحة وتعمل هذه الهياكل على تحديد الأدفاق السّياحيّة وتحديد الاختيارات التّنمويّة ووضع المخطّطات ورصد الاعتمادات.الأطراف الدّوليّة:تتمثّل أساسا في المنظّمة العالميّة للسياحة والمنظّمات الإقليميّة التاّبعة بها (كالمنظّمة العربيّة للسّياحة…) وهي منظّمة دوليّة متخصصّة في السّياحة وطرفا فاعلا في الأدفاق السّياحيّة وهي هيكل أممي لها مهام متنوّعة منها:القيام بدراسات.تنظيم النّدوات والمؤتمرات.سنّ التّشريعات الخاصّة بالسّياحة.تقديم مساعدات للبلدان الأعضاء.المنظمات الغير حكومية:تركّز أنشطتها على الحد من التّأثيرات البيئيّة السّلبيّة لبعض أصناف السّياحة كالسّياحة الجماهريّة الاستحماميّة وتطالب بسياحة مستديمة تحافظ على البيئة وبسياحة عادلة تنصف شعوب بلدان الجنوب وتحد من استنزاف مواردها مثل منظّمة السّلام الأخضر.الأطراف الخاصّة:هي متنوّعة كالشّركات السّياحيّة العبر قُطرية والسّلاسل الفندقيّة وشركات الاستشارة والتّسيير وشركات التّأمين وشركات أخرى خاصّة مثل شركات الطّيران والرّحلات البحريّة والبنوك والمطاعم وشركات الإشهار.وقد أصبحت السّوق السّياحيّة العالميّة في يد عدد محدود من الشّركات السّياحيّة عبر قطريّة تنتمي في جلّها إلى بلدان الشّمال خاصة الولايات المتحدّة الأمريكيّة وبدأ دورها يتعاظم بفضل الشّراء والإدماج. وتمكّنت هذه الشركات من إدماج تكنولوجيا الاتصال والإعلام الحديثة في نطاق واسع (التّسويق والحجز).وتمكنت من إقامة نظام سياحي عالمي بفضل استثماراتها في مختلف أنحاء العالم خاصّة في بلدان الجنوب واستفادت من العلاقات الغير متكافئة عن طريق تنميط العرض السّياحي يعني اعتماد صيغة عرض ‘الكّل مدمج” ثم ترحيل المرابيح التي تجنيها إلى بلدانها الأصليّة وما يتبقّى للبلدان النّامية من العائدات الماليّة السّياحيّة لا يتجاوز 10% من مجموع المداخيل.خاتمة:مثّلت الأدفاق السّياحيّة العالميّة مظهرا من مظاهر ترابط العالم وجعل البعض يتحدّث عن نظام سياحي عالمي لكن هذا النظام تستفيد منه بلدان الشّمال.`//splitLessonContentIntoSections(exampleLesson); ---File: splitLessonContentIntoSectionsUsingAi.js --- const useGeminiAPI = require('./useGeminiAPI.js');const useGPT4API = require('./useGPT4API.js');const useLlamaAPI = require('./useLlamaAPI.js');const {useGeminiProAPI} = require('./useGeminiProAPI.js');const splitLessonContentIntoSections = async (content) => {    const prompt = `        please read this lesson content:    "${content}".        Split the following lesson content into logical 5 or less sections (the less sections the better ) following these guidelines:   IF YOU split into :     - only 1 section : EXCELLENT but only works if the lesson content is short enough     - 2 sections: VERY GOOD     - 3 sections: GOOD    - 4 sections: a little bit too much but still OK*    - 5 sections: TOO MUCH, but still OK if the lesson content is too long    - 6 sections: BAD and only acceptable if the lesson content is long enough, this is unless you really have to.    - 7 sections: VERY BAD    - 8 sections: UNACCEPTABLE.    BUT IN ALL CASES DO NOT LEAVE ANYTHING OUT FROM THE LESSON CONTENT; WE NEED EVERYTHING IN THE LESSON CONTENT.    * **Content:**        * Include ALL lesson content without modification, do not alter in any way the original text. and do not leave anything out        * Maintain the original order of the content.    * **Titles:**        * Use the same language as the content.         * Create concise summaries of the section content, providing enough context for standalone use (e.g., in a quiz).        * Avoid using numbers to indicate section order.    * **Section Length:**        * Ensure each section is at least 2 paragraphs long.        * Combine short sections with relevant ones to achieve sufficient length.         * For very short sections (less than 300 characters), combine them even if unrelated, using a title like "Section 1 Title / Section 2 Title".     STRICT: USE SAME LANGUAGE AS THE CONTENT, DO NOT ALTER THE ORIGINAL TEXT, DO NOT LEAVE ANYTHING OUT, MAINTAIN THE ORIGINAL ORDER OF THE CONTENT.IMPORTANT: DO NOT PUT SMALL SECTIONS! i don't care how you mix the section jsut do not put small sections.        ONLY RETURN JSON IN THE FOLLOWING STRUCTURE, REPONSE SHOULD BE JUST VALID JSON OBJECT FORMAT SIMILAR TO THE EXAMPLE BELOW:    {"sections": [                    {                        "sectionTitle": "Section 1",                        sectionContent: " content"                    },                                    ]      }    ONLY RETURN VALID JSON OBJECT     `    let response;    let attempts = 0;    while (attempts < 3) {      try {        // Use the gemini api to split the content into sections, give it the prompt      // response = await useGeminiAPI({parts: [{text: JSON.stringify(prompt)}], parseResponse: true});      response = await useLlamaAPI({parts: [{text: JSON.stringify(prompt)}], parseResponse: true});       // console.log(response);        break; // Exit the loop if the response is obtained successfully      } catch (error) {        console.error(`Attempt ${attempts + 1} failed: ${error}`);        attempts++;        if (attempts >= 3) {          throw new Error('Failed to split lesson content into sections after 3 attempts');        }      }    }    return response;  }module.exports = splitLessonContentIntoSections;const exampleLesson = `الملخص:ما إن تحصلت البلاد التونسية على استقلالها حتى شرعت في بناء الدولة العصرية واستكمال السيادة الوطنية وتحديث المجتمع…I- بناء الدولة العصرية واستكمال السيادة:1- بناء الدولة العصرية:أ) إرساء النظام الجمهوري: تم ذلك من خلال:إنشاء المجلس القومي التأسيسي يوم 29 ديسمبر 1955 وكانت مهمته إعداد دستور البلاد.إلغاء النظام الملكي وإعلان الجمهورية من قبل المجلس الوطني التأسيسي يوم 25 جويلية 1957 وتكليف الحبيب بورقيبة برئاسة الجمهورية.إعلان الدستور يوم 1 جوان 1959 الذي أقر النظام الجمهوري القائم على مبدأ الفصل بين السلط واحترام حقوق الإنسان والمواطن.ب) تونسة دواليب الدولة:أقدمت الحكومة التونسية على:تونسة الأمن ببعث وحدات الشرطة والحرس الوطني يوم 18 أفريل 1956.حذف سلك العمال والخلفاوات وتعويضهم بالولاة والمعتمدين يوم 21 جوان 1956. كما عوضت تدريجيا الإداريين الفرنسيين بموظفين تونسيين.انخراط تونس في منظمة الأمم المتحدة يوم 12 نوفمبر 1956. كما قامت بربط علاقات ديبلوماسية مع عدة بلدان…ج) الحد من التبعية الاقتصادية من خلال:تأميم القطاعات الحيوية مثل السكك الحديدية والمواني، إنتاج وتوزيع المياه والكهرباء والغاز.إلغاء الوحدة الجمركية مع فرنسا يوم 20 أوت 1956.2- استكمال السيادة الوطنية:أ) الجلاء العسكري 1956-1963:طالب بورقيبة منذ جوان 1956 بالجلاء العسكري عن البلاد لكن فرنسا رفضت ذلك لتضييق الخناق على الثورة الجزائرية وقامت باعتداءات عديدة على القرى الحدودية أخطرها على قرية ساقية سيدي يوسف.أمام تصعيد المقاومة الوطنية أجلت فرنسا قواتها عن كامل البلاد باستثناء قاعدة بنزرت فأعلنت الحكومة التونسية معركة الجلاء في جويلية 1961. وفي 15 أكتوبر 1963 أجلت فرنسا قواتها عن بنزرت.ب) الجلاء الزراعي:تم من خلال:شراء أراضي المعمرين أو ضم أراضي الفارين منهم.إصدار قانون 12 ماي 1964 الذي ينص على تأميم ما تبقى من أراضي المعمرين بتونس.II- تحديث المجتمع التونسي:1) توحيد التشريع وتعصيره:لم يكن التشريع في البلاد التونسية في الفترة الاستعمارية موحدا ولا متجانسا فهنالك المحاكم الشرعية ومجالس الأحبار والمحاكم العصرية التونسية والمحاكم الفرنسية لذلك بادرت الدولة التونسية المستقلة بتوحيد القضاء وتعصيره بالاعتماد على التشريع الإسلامي وبالاستلهام من القوانين الحديثة كما أصدرت مجلة الأحوال الشخصية.2) تحرير المرأة:كانت المرأة محرومة من حقوقها السياسية والمدنية فبادرت الدولة بإصدار مجلة الأحوال الشخصية التي تضمنت عدة إجراءات: منع تعدد الزوجات، إقرار الطلاق بحكم عدلي، تحديد سن الزواج للجنسين كما أصبح للمرأة الحق في الانتخاب والترشح لكل المسؤوليات (قانون 4 مارس 1957).3) توحيد التعليم وتعصيره:لم يكن التعليم قبل الاستقلال موحدا، فقد تنوعت البرامج وتعددت المدارس (تقليدية، عصرية، مختلطة)، لذلك صدر قانون 4 نوفمبر 1958 لتوحيد التعليم وتعصيره ومجانيته وفتحه أمام الجميع، كما رصدت اعتمادات مالية ضخمة لفائدة التعليم تقدر بربع الميزانية العامة للدولة مما أدى إلى ارتفاع نسبة التمدرس وتعدد المدارس.III- التجارب التنموية وحصيلتها:1) تجربة التعاضد خلال الستينات (الاشتراكية الدستورية):تميزت بالتدخل المكثف للدولة في عملية التنمية بدون القضاء على الملكية الفردية حيث تم الشروع في تطبيق مخططات رباعية في إطار الآفاق العشرية للتنمية 1971/1962.ارتكزت التجربة على سياسة التعاضد خاصة في القطاع الفلاحي، إذ بادرت الدولة بتكوين تعاضيات إنتاج نموذجية بفضل الأراضي الشاسعة التي استرجعتها من المعمرين ثم شرع في تجميع صغار الفلاحين في تعاضديات إنتاج مماثلة إلى جانب تعاضديات خدمات بهدف تعصير طرق الإنتاج وتشغيل اليد العاملة.وجدت تجربة التعاضد مقاومة كبيرة خاصة عندما اتخذ قرار تعميم التعاضد سنة 1969 فتم العدول عن النظام التعاضدي في 22 سبتمبر 1969.أما في القطاع الصناعي فقد أعطت الدولة الأولوية المطلقة للتصنيع، إذ رصدت له ما لا يقل عن 40.3% من مجموع الاستثمارات المدرجة في المخطط العشري فتمكنت من بعث أقطاب تنموية إقليمية بهدف تصنيع البلاد والحد من اختلال التوازن الإقليمي.واجهت تجربة التعاضد عدة صعوبات فتم اللجوء إلى اعتماد المنهج الليبرالي…2) تجربة تنموية ليبرالية منذ بداية السبعينات:بقيت الدولة أول مستثمر إلا أنها اتخذت إجراءات في اتجاه المنهج التحرري الليبرالي من ذلك:حل التعاضديات الفلاحية والتجارية وإعادة الملكيات لأصحابها.التفويت في جزء من الأراضي الدولية للخواص وفي بعض المؤسسات الصناعية.تشجيع الخواص ودعم النشاط السياحي.مكنت هذه التجربة من تحقيق تنموية اقتصادية واجتماعية خاصة أثناء النصف الأول من السبعينات مستفيدة من ظرفية ملائمة (سنوات ممطرة، ارتفاع أسعار النفط) ومنذ منتصف السبعينات عرفت هذه التجربة عدة صعوبات تعمقت في النصف الأول من الثمانينات (تراجع اسعار الفسفاط والنفط، سياسة حمائية اتخذتها السوق الأوروبية المشتركة) مما استوجب اعتماد برنامج الإصلاح الهيكلي سنة 1986.3) الحصيلة:اقتصاديا:عرفت البلاد تحولا في بنية الاقتصاد من اقتصاد تقليدي (فلاحي منجمي) إلى اقتصاد متنوع الموارد، يرتكز على الصناعة والخدمات كما تدعمت مكانة السياحة غير أن ذلك لا يحجب عدة اختلالات منها: عجز الميزان التجاري، تفاقم المديونية، التبعية للخارج…اجتماعيا:شهدت البلاد بداية التحكم في النمو الديمغرافي، ارتفاعا في نسبة التمدرس، تحسنا في مستوى العيش ورغم ذلك بقي التفاوت قائما في مستوى العيش بين الفئات والجهات، كما تواصلت ظاهرة البطالة.شهدت البلاد التونسية في العهد البورقيبي تحولات كبيرة في مختلف المجالات لإرساء الدولة العصرية لكن منذ منتصف الثمانينات عرفت البلاد أزمة حادة أدت إلى تحول السابع من نوفمبر 1987.`//splitLessonContentIntoSections(exampleLesson); ---File: tempCodeRunnerFile.js ---     const sections = inputText.split('#\n').filter(section => section.trim() !== '');    const parsedObject = {        relevantLessonPartDescription: "",        questions: [],        correctAnswers: {}    };      let currentQuestion = null;      sections.forEach((section, index) => {        let [type, content] = section.split('|', 2);        // Ensure we remove only the initial type character from the content        content = content ? content.trim() : '';        switch (type.trim()) {            case 'r':                parsedObject.relevantLessonPartDescription += content;                break;            case 'q':                if (currentQuestion !== null) {                    parsedObject.questions.push(currentQuestion);                }                currentQuestion = { question: content, answers: [], correctAnswerJustificationFromLesson: "", difficultyLevel: "" };                break;            case 'a':                if(currentQuestion) currentQuestion.answers.push(content);                break;            case 'c':                if(currentQuestion) parsedObject.correctAnswers[parsedObject.questions.length] = [parseInt(content) - 1];                break;            case 'j':                if(currentQuestion) currentQuestion.correctAnswerJustificationFromLesson = content;                break;            case 'd':                if(currentQuestion) currentQuestion.difficultyLevel = content;                break;        }    });      if (currentQuestion !== null) {        parsedObject.questions.push(currentQuestion);    }      return parsedObject; ---File: useGPT4API.js --- const axios = require('axios');const appRoot = require('app-root-path');require('dotenv').config({ path: `${appRoot}/.env` });const clc = require('cli-color');// Throttling setuplet requestCount = 0;const requestLimit = 60;const requestInterval = 60000; // 60 secondslet lastRequestTime = Date.now();async function useGPT4API({parts = [{"text": "create a simple json object of imaginary data"}], parseResponse= true}) {  const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;  const url = `https://openrouter.ai/api/v1/chat/completions`;  const data = {   "model": "openai/gpt-4-turbo-2024-04-09",  //  "model": "google/gemini-pro-1.5",    "messages": parts.map(part => ({ "role": "user", "content": part.text.replace(/\n/g, " ") })),  };  console.log(data)  // Throttle requests if limit is reached  const currentTime = Date.now();  if (requestCount >= requestLimit && (currentTime - lastRequestTime) < requestInterval) {    const waitTime = requestInterval - (currentTime - lastRequestTime);    console.log(clc.yellow(`THROTTLING OpenRouter API requests so we don't surpass limit per minute. Waiting for ${waitTime / 1000}s.`));    await new Promise(resolve => setTimeout(resolve, waitTime));    requestCount = 0; // Reset request count after waiting    lastRequestTime = Date.now(); // Update last request time  }  try {    const response = await fetch(url, {      method: "POST",      headers: {        "Authorization": `Bearer ${OPENROUTER_API_KEY}`,        "Content-Type": "application/json"      },      body: JSON.stringify(data)    });    requestCount++; // Increment request count after a successful request    const responseData = await response.json();    if (responseData.error) {      console.log(clc.red(`OpenRouter API returned an error: ${responseData.error.message}`));    }    // Assuming the response structure is similar to what was expected from Gemini API    // Stick the parts together and return them as one string     let content = responseData.choices[0].message.content;    //if content starts with ```json remove it and the last ```    if (content?.trim().startsWith("```json")) {      content = content.replace("```json", "");    }    if (content?.trim().endsWith("```")) {      content = content.slice(0, -3);    }    if (parseResponse) {      const firstBraceIndex = content.indexOf('{');      const lastBraceIndex = content.lastIndexOf('}');      content = content.substring(firstBraceIndex, lastBraceIndex + 1);    }    const parsedContent = parseResponse ?  (JSON.parse(content)) : content;    console.log(content)    console.log(JSON.parse(content))    return parsedContent      } catch (error) {    console.log(content)    console.error(clc.red(`Error using OpenRouter API: ${error.message}`));    throw error; // Rethrow the error to be handled by the caller  }}module.exports = useGPT4API; ---File: useGeminiAPI.js --- const axios = require('axios');const appRoot = require('app-root-path');require('dotenv').config({ path: `${appRoot}/.env` });const clc = require('cli-color');const HttpsProxyAgent = require('https-proxy-agent');const convertQuizGenerationToStandardStructure = require('./convertQuizGenerationToStandardStructure.js');// Throttling setuplet requestCount = 0;const requestLimit = 60;const requestInterval = 60000; // 60 secondslet lastRequestTime = Date.now();async function useGeminiAPI({parts = [{"text": "create a simple json object of imaginary data"}], parseResponse= true, temperature = 0.8}) {  const API_KEY = process.env.GOOGLE_GEMINI_API_KEY;  const proxyUrl = 'http://brd.superproxy.io:22225';  const proxyAuth = 'brd-customer-hl_d4fbf205-zone-datacenter_proxy2-country-us:e8s3pvz740xb';  const agent = new HttpsProxyAgent({    host: 'brd.superproxy.io',    port: 22225,    auth: proxyAuth,  });  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.0-pro:generateContent?key=${API_KEY}`;  const data = {    "contents": [      {        role: "user",        "parts": parts      }    ],    "generationConfig": {      "temperature": temperature,      "topK": 1,      "topP": 1,      "maxOutputTokens": 8192,      "stopSequences": []    },    "safetySettings": [      {        "category": "HARM_CATEGORY_HARASSMENT",        "threshold": "BLOCK_NONE"      },      {        "category": "HARM_CATEGORY_HATE_SPEECH",        "threshold": "BLOCK_NONE"      },      {        "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",        "threshold": "BLOCK_NONE"      },      {        "category": "HARM_CATEGORY_DANGEROUS_CONTENT",        "threshold": "BLOCK_NONE"      }    ]  };  // Throttle requests if limit is reached  const currentTime = Date.now();  if (requestCount >= requestLimit && (currentTime - lastRequestTime) < requestInterval) {    const waitTime = requestInterval - (currentTime - lastRequestTime);    console.log(clc.yellow(`THROTTLING Gemini API requests so we don't surpass limit per minute. Waiting for ${waitTime / 1000}s.`));    await new Promise(resolve => setTimeout(resolve, waitTime));    requestCount = 0; // Reset request count after waiting    lastRequestTime = Date.now(); // Update last request time  }  try {    const response = await axios.post(url, data, {    //  httpsAgent: agent,      headers: {        'Content-Type': 'application/json'      }    });    requestCount++; // Increment request count after a successful request    if (response?.data?.promptFeedback?.blockReason === 'SAFETY') console.log(clc.red(`Gemini API blocked the request: ${response.data.promptFeedback.blockReason}`));    const responseParts = response.data.candidates[0].content.parts;        let content = responseParts.map(part => part.text).join('\n')        if (content.startsWith("```json")) {          content = content.replace("```json", "");        }        if (content.endsWith("```")) {          content = content.slice(0, -3);        }        console.log(content)        const parsedContent = parseResponse ?  (JSON.parse(content)) : content;        console.log(clc.green(`Parsed content`));        console.log(parsedContent)            return parsedContent         } catch (error) {    console.error(clc.red(`Error using Gemini API: ${JSON.stringify(error.response ? error.response.data : error.message)}`));    throw error; // Rethrow the error to be handled by the caller  }}module.exports = useGeminiAPI; ---File: useGeminiProAPI.js --- const appRoot = require('app-root-path');require('dotenv').config({ path: `${appRoot}/.env` });const { VertexAI } = require('@google-cloud/vertexai');const clc = require('cli-color');// Initialize Vertex with your Cloud project and locationconst possibleLocations = [  "asia-east1",  "asia-east2",  "asia-northeast1",  "asia-northeast3",  "asia-south1",  "asia-southeast1",  "australia-southeast1",  "europe-central2",  "europe-north1",  "europe-south1",  "europe-west1",  "europe-west2",  "europe-west3",  "europe-west4",  "europe-west6",  "europe-west8",  "me-west1",  "northamerica-northeast1",  "southamerica-east1",  "us-central1",  "us-east1",  "us-east4",  "us-east5",  "us-south1",  "us-west1",  "us-west4",  ]async function useGeminiProAPI({ parts = [{ "text": "create a simple json object of imaginary data" }], parseResponse = true }) {  const randomLocation = possibleLocations[Math.floor(Math.random() * possibleLocations.length)];  console.log(clc.yellow(`Using location: ${randomLocation}`));  const vertexAI = new VertexAI({ project: 'class-clash', location: randomLocation });  const model = 'gemini-1.5-pro-preview-0409';// Instantiate the modelsconst generativeModel = vertexAI.preview.getGenerativeModel({  model: model,  generationConfig: {    'maxOutputTokens': 8192,    'temperature': 1,    'topP': 0.95,  }});  try {    const mergedText = parts.map(part => part.text.trim()).join(" ").replace(/\n/g, " ");    console.log(mergedText)    const req = { contents: [{ role: 'user', parts: [{ text: mergedText }] }] };    console.log(clc.magenta(`Sending request...`));    const response = await generativeModel.generateContent(req);    let content = response.response.candidates[0].content.parts[0].text;    if (parseResponse) {      const firstBraceIndex = content.indexOf('{');      const lastBraceIndex = content.lastIndexOf('}');      content = content.substring(firstBraceIndex, lastBraceIndex + 1);    }    const parsedContent = parseResponse ? JSON.parse(content) : content;    console.log(clc.green(`Parsed content`));    console.log(parsedContent)    return parsedContent;  } catch (error) {    console.error(clc.red(`Error using Google Vertex AI: ${error.message}`));    throw error;  }}const queue = [];let activeProcesses = 0;const maxConcurrentProcesses = 2;async function useGeminiProApiWithQueue({ parts = [{ "text": "create a simple json object of imaginary data" }], parseResponse = true }) {  async function processQueue() {    if (activeProcesses >= maxConcurrentProcesses || queue.length === 0) {      return;    }      activeProcesses++;    const { parts, parseResponse, resolve, reject } = queue.shift();    console.log(clc.magenta(`Item REMOVED from queue.`) + clc.white(` Items left in queue: `) + clc.green(`${queue.length}`));    try {      const response = await useGeminiProAPI({ parts, parseResponse });      resolve(response);    } catch (error) {      reject(error);    } finally {      activeProcesses--;      if (queue.length > 0) {        processQueue();      }    }  }  return new Promise((resolve, reject) => {    queue.push({ parts, parseResponse, resolve, reject });    console.log(clc.green(`Item ADDED to queue. Total items in queue: ${queue.length}`));    if (activeProcesses < maxConcurrentProcesses) {      processQueue();    }  });}const prompt = `hello world what is today's date yo?`;const testGeminiWithDelay = async () => {  let requestCount = 0;  while (true) {          useGeminiProApiWithQueue(prompt)       .then(() => {         console.log(clc.green(`Request number: ${requestCount}`));       })       .catch((error) => {        // console.error(clc.red(`Error - ${error.message}`));       })       .finally(() => {        requestCount++;      });    const delay = 1000;   // console.log(clc.yellow(`Delaying for ${delay} milliseconds...`));    await new Promise(resolve => setTimeout(resolve, delay));  }}module.exports = {useGeminiProAPI, useGeminiProApiWithQueue}; ---File: useLlamaAPI.js --- const axios = require('axios');const appRoot = require('app-root-path');require('dotenv').config({ path: `${appRoot}/.env` });const clc = require('cli-color');// Throttling setuplet requestCount = 0;const requestLimit = 60;const requestInterval = 60000; // 60 secondslet lastRequestTime = Date.now();async function useLlamaAPI({parts = [{"text": "create a simple json object of imaginary data"}], parseResponse= true}) {  const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;  const url = `https://openrouter.ai/api/v1/chat/completions`;  const data = {   "model": "meta-llama/llama-3-70b-instruct",  //  "model": "google/gemini-pro-1.5",    "messages": parts.map(part => ({ "role": "user", "content": part.text.replace(/\n/g, " ") })),  };  console.log(data)  // Throttle requests if limit is reached  const currentTime = Date.now();  if (requestCount >= requestLimit && (currentTime - lastRequestTime) < requestInterval) {    const waitTime = requestInterval - (currentTime - lastRequestTime);    console.log(clc.yellow(`THROTTLING OpenRouter API requests so we don't surpass limit per minute. Waiting for ${waitTime / 1000}s.`));    await new Promise(resolve => setTimeout(resolve, waitTime));    requestCount = 0; // Reset request count after waiting    lastRequestTime = Date.now(); // Update last request time  }  try {    const response = await fetch(url, {      method: "POST",      headers: {        "Authorization": `Bearer ${OPENROUTER_API_KEY}`,        "Content-Type": "application/json"      },      body: JSON.stringify(data)    });    requestCount++; // Increment request count after a successful request    const responseData = await response.json();    if (responseData.error) {      console.log(clc.red(`OpenRouter API returned an error: ${responseData.error.message}`));    }    // Assuming the response structure is similar to what was expected from Gemini API    // Stick the parts together and return them as one string     let content = responseData.choices[0].message.content;    //if content starts with ```json remove it and the last ```    if (content?.trim().startsWith("```json")) {      content = content.replace("```json", "");    }    if (content?.trim().endsWith("```")) {      content = content.slice(0, -3);    }    if (parseResponse) {      const firstBraceIndex = content.indexOf('{');      const lastBraceIndex = content.lastIndexOf('}');      content = content.substring(firstBraceIndex, lastBraceIndex + 1);    }    const parsedContent = parseResponse ?  (JSON.parse(content)) : content;    console.log(content)    console.log(JSON.parse(content))    return parsedContent      } catch (error) {    console.log(content)    console.error(clc.red(`Error using OpenRouter API: ${error.message}`));    throw error; // Rethrow the error to be handled by the caller  }}module.exports = useLlamaAPI; ---